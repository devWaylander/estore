// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package service

//go:generate minimock -i route256.ozon.ru/project/cart/internal/service.Repository -o repository_mock_test.go -n RepositoryMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/cart/internal/model"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddGoodToCart          func(ctx context.Context, userID int64, good model.Good) (err error)
	inspectFuncAddGoodToCart   func(ctx context.Context, userID int64, good model.Good)
	afterAddGoodToCartCounter  uint64
	beforeAddGoodToCartCounter uint64
	AddGoodToCartMock          mRepositoryMockAddGoodToCart

	funcCleanUpCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncCleanUpCart   func(ctx context.Context, userID int64)
	afterCleanUpCartCounter  uint64
	beforeCleanUpCartCounter uint64
	CleanUpCartMock          mRepositoryMockCleanUpCart

	funcCreateCart          func(ctx context.Context, userID int64) (c2 model.Cart, err error)
	inspectFuncCreateCart   func(ctx context.Context, userID int64)
	afterCreateCartCounter  uint64
	beforeCreateCartCounter uint64
	CreateCartMock          mRepositoryMockCreateCart

	funcGetCartByUserID          func(ctx context.Context, userID int64) (c2 model.Cart, err error)
	inspectFuncGetCartByUserID   func(ctx context.Context, userID int64)
	afterGetCartByUserIDCounter  uint64
	beforeGetCartByUserIDCounter uint64
	GetCartByUserIDMock          mRepositoryMockGetCartByUserID

	funcRemoveGoodFromCart          func(ctx context.Context, userID int64, skuID uint32) (err error)
	inspectFuncRemoveGoodFromCart   func(ctx context.Context, userID int64, skuID uint32)
	afterRemoveGoodFromCartCounter  uint64
	beforeRemoveGoodFromCartCounter uint64
	RemoveGoodFromCartMock          mRepositoryMockRemoveGoodFromCart
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddGoodToCartMock = mRepositoryMockAddGoodToCart{mock: m}
	m.AddGoodToCartMock.callArgs = []*RepositoryMockAddGoodToCartParams{}

	m.CleanUpCartMock = mRepositoryMockCleanUpCart{mock: m}
	m.CleanUpCartMock.callArgs = []*RepositoryMockCleanUpCartParams{}

	m.CreateCartMock = mRepositoryMockCreateCart{mock: m}
	m.CreateCartMock.callArgs = []*RepositoryMockCreateCartParams{}

	m.GetCartByUserIDMock = mRepositoryMockGetCartByUserID{mock: m}
	m.GetCartByUserIDMock.callArgs = []*RepositoryMockGetCartByUserIDParams{}

	m.RemoveGoodFromCartMock = mRepositoryMockRemoveGoodFromCart{mock: m}
	m.RemoveGoodFromCartMock.callArgs = []*RepositoryMockRemoveGoodFromCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddGoodToCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddGoodToCartExpectation
	expectations       []*RepositoryMockAddGoodToCartExpectation

	callArgs []*RepositoryMockAddGoodToCartParams
	mutex    sync.RWMutex
}

// RepositoryMockAddGoodToCartExpectation specifies expectation struct of the Repository.AddGoodToCart
type RepositoryMockAddGoodToCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddGoodToCartParams
	results *RepositoryMockAddGoodToCartResults
	Counter uint64
}

// RepositoryMockAddGoodToCartParams contains parameters of the Repository.AddGoodToCart
type RepositoryMockAddGoodToCartParams struct {
	ctx    context.Context
	userID int64
	good   model.Good
}

// RepositoryMockAddGoodToCartResults contains results of the Repository.AddGoodToCart
type RepositoryMockAddGoodToCartResults struct {
	err error
}

// Expect sets up expected params for Repository.AddGoodToCart
func (mmAddGoodToCart *mRepositoryMockAddGoodToCart) Expect(ctx context.Context, userID int64, good model.Good) *mRepositoryMockAddGoodToCart {
	if mmAddGoodToCart.mock.funcAddGoodToCart != nil {
		mmAddGoodToCart.mock.t.Fatalf("RepositoryMock.AddGoodToCart mock is already set by Set")
	}

	if mmAddGoodToCart.defaultExpectation == nil {
		mmAddGoodToCart.defaultExpectation = &RepositoryMockAddGoodToCartExpectation{}
	}

	mmAddGoodToCart.defaultExpectation.params = &RepositoryMockAddGoodToCartParams{ctx, userID, good}
	for _, e := range mmAddGoodToCart.expectations {
		if minimock.Equal(e.params, mmAddGoodToCart.defaultExpectation.params) {
			mmAddGoodToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddGoodToCart.defaultExpectation.params)
		}
	}

	return mmAddGoodToCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddGoodToCart
func (mmAddGoodToCart *mRepositoryMockAddGoodToCart) Inspect(f func(ctx context.Context, userID int64, good model.Good)) *mRepositoryMockAddGoodToCart {
	if mmAddGoodToCart.mock.inspectFuncAddGoodToCart != nil {
		mmAddGoodToCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddGoodToCart")
	}

	mmAddGoodToCart.mock.inspectFuncAddGoodToCart = f

	return mmAddGoodToCart
}

// Return sets up results that will be returned by Repository.AddGoodToCart
func (mmAddGoodToCart *mRepositoryMockAddGoodToCart) Return(err error) *RepositoryMock {
	if mmAddGoodToCart.mock.funcAddGoodToCart != nil {
		mmAddGoodToCart.mock.t.Fatalf("RepositoryMock.AddGoodToCart mock is already set by Set")
	}

	if mmAddGoodToCart.defaultExpectation == nil {
		mmAddGoodToCart.defaultExpectation = &RepositoryMockAddGoodToCartExpectation{mock: mmAddGoodToCart.mock}
	}
	mmAddGoodToCart.defaultExpectation.results = &RepositoryMockAddGoodToCartResults{err}
	return mmAddGoodToCart.mock
}

// Set uses given function f to mock the Repository.AddGoodToCart method
func (mmAddGoodToCart *mRepositoryMockAddGoodToCart) Set(f func(ctx context.Context, userID int64, good model.Good) (err error)) *RepositoryMock {
	if mmAddGoodToCart.defaultExpectation != nil {
		mmAddGoodToCart.mock.t.Fatalf("Default expectation is already set for the Repository.AddGoodToCart method")
	}

	if len(mmAddGoodToCart.expectations) > 0 {
		mmAddGoodToCart.mock.t.Fatalf("Some expectations are already set for the Repository.AddGoodToCart method")
	}

	mmAddGoodToCart.mock.funcAddGoodToCart = f
	return mmAddGoodToCart.mock
}

// When sets expectation for the Repository.AddGoodToCart which will trigger the result defined by the following
// Then helper
func (mmAddGoodToCart *mRepositoryMockAddGoodToCart) When(ctx context.Context, userID int64, good model.Good) *RepositoryMockAddGoodToCartExpectation {
	if mmAddGoodToCart.mock.funcAddGoodToCart != nil {
		mmAddGoodToCart.mock.t.Fatalf("RepositoryMock.AddGoodToCart mock is already set by Set")
	}

	expectation := &RepositoryMockAddGoodToCartExpectation{
		mock:   mmAddGoodToCart.mock,
		params: &RepositoryMockAddGoodToCartParams{ctx, userID, good},
	}
	mmAddGoodToCart.expectations = append(mmAddGoodToCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddGoodToCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddGoodToCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddGoodToCartResults{err}
	return e.mock
}

// AddGoodToCart implements Repository
func (mmAddGoodToCart *RepositoryMock) AddGoodToCart(ctx context.Context, userID int64, good model.Good) (err error) {
	mm_atomic.AddUint64(&mmAddGoodToCart.beforeAddGoodToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddGoodToCart.afterAddGoodToCartCounter, 1)

	if mmAddGoodToCart.inspectFuncAddGoodToCart != nil {
		mmAddGoodToCart.inspectFuncAddGoodToCart(ctx, userID, good)
	}

	mm_params := RepositoryMockAddGoodToCartParams{ctx, userID, good}

	// Record call args
	mmAddGoodToCart.AddGoodToCartMock.mutex.Lock()
	mmAddGoodToCart.AddGoodToCartMock.callArgs = append(mmAddGoodToCart.AddGoodToCartMock.callArgs, &mm_params)
	mmAddGoodToCart.AddGoodToCartMock.mutex.Unlock()

	for _, e := range mmAddGoodToCart.AddGoodToCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddGoodToCart.AddGoodToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddGoodToCart.AddGoodToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddGoodToCart.AddGoodToCartMock.defaultExpectation.params
		mm_got := RepositoryMockAddGoodToCartParams{ctx, userID, good}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddGoodToCart.t.Errorf("RepositoryMock.AddGoodToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddGoodToCart.AddGoodToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddGoodToCart.t.Fatal("No results are set for the RepositoryMock.AddGoodToCart")
		}
		return (*mm_results).err
	}
	if mmAddGoodToCart.funcAddGoodToCart != nil {
		return mmAddGoodToCart.funcAddGoodToCart(ctx, userID, good)
	}
	mmAddGoodToCart.t.Fatalf("Unexpected call to RepositoryMock.AddGoodToCart. %v %v %v", ctx, userID, good)
	return
}

// AddGoodToCartAfterCounter returns a count of finished RepositoryMock.AddGoodToCart invocations
func (mmAddGoodToCart *RepositoryMock) AddGoodToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGoodToCart.afterAddGoodToCartCounter)
}

// AddGoodToCartBeforeCounter returns a count of RepositoryMock.AddGoodToCart invocations
func (mmAddGoodToCart *RepositoryMock) AddGoodToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGoodToCart.beforeAddGoodToCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddGoodToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddGoodToCart *mRepositoryMockAddGoodToCart) Calls() []*RepositoryMockAddGoodToCartParams {
	mmAddGoodToCart.mutex.RLock()

	argCopy := make([]*RepositoryMockAddGoodToCartParams, len(mmAddGoodToCart.callArgs))
	copy(argCopy, mmAddGoodToCart.callArgs)

	mmAddGoodToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddGoodToCartDone returns true if the count of the AddGoodToCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddGoodToCartDone() bool {
	for _, e := range m.AddGoodToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddGoodToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddGoodToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGoodToCart != nil && mm_atomic.LoadUint64(&m.afterAddGoodToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddGoodToCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddGoodToCartInspect() {
	for _, e := range m.AddGoodToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddGoodToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddGoodToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddGoodToCartCounter) < 1 {
		if m.AddGoodToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddGoodToCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddGoodToCart with params: %#v", *m.AddGoodToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGoodToCart != nil && mm_atomic.LoadUint64(&m.afterAddGoodToCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddGoodToCart")
	}
}

type mRepositoryMockCleanUpCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCleanUpCartExpectation
	expectations       []*RepositoryMockCleanUpCartExpectation

	callArgs []*RepositoryMockCleanUpCartParams
	mutex    sync.RWMutex
}

// RepositoryMockCleanUpCartExpectation specifies expectation struct of the Repository.CleanUpCart
type RepositoryMockCleanUpCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCleanUpCartParams
	results *RepositoryMockCleanUpCartResults
	Counter uint64
}

// RepositoryMockCleanUpCartParams contains parameters of the Repository.CleanUpCart
type RepositoryMockCleanUpCartParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockCleanUpCartResults contains results of the Repository.CleanUpCart
type RepositoryMockCleanUpCartResults struct {
	err error
}

// Expect sets up expected params for Repository.CleanUpCart
func (mmCleanUpCart *mRepositoryMockCleanUpCart) Expect(ctx context.Context, userID int64) *mRepositoryMockCleanUpCart {
	if mmCleanUpCart.mock.funcCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("RepositoryMock.CleanUpCart mock is already set by Set")
	}

	if mmCleanUpCart.defaultExpectation == nil {
		mmCleanUpCart.defaultExpectation = &RepositoryMockCleanUpCartExpectation{}
	}

	mmCleanUpCart.defaultExpectation.params = &RepositoryMockCleanUpCartParams{ctx, userID}
	for _, e := range mmCleanUpCart.expectations {
		if minimock.Equal(e.params, mmCleanUpCart.defaultExpectation.params) {
			mmCleanUpCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanUpCart.defaultExpectation.params)
		}
	}

	return mmCleanUpCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.CleanUpCart
func (mmCleanUpCart *mRepositoryMockCleanUpCart) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockCleanUpCart {
	if mmCleanUpCart.mock.inspectFuncCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CleanUpCart")
	}

	mmCleanUpCart.mock.inspectFuncCleanUpCart = f

	return mmCleanUpCart
}

// Return sets up results that will be returned by Repository.CleanUpCart
func (mmCleanUpCart *mRepositoryMockCleanUpCart) Return(err error) *RepositoryMock {
	if mmCleanUpCart.mock.funcCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("RepositoryMock.CleanUpCart mock is already set by Set")
	}

	if mmCleanUpCart.defaultExpectation == nil {
		mmCleanUpCart.defaultExpectation = &RepositoryMockCleanUpCartExpectation{mock: mmCleanUpCart.mock}
	}
	mmCleanUpCart.defaultExpectation.results = &RepositoryMockCleanUpCartResults{err}
	return mmCleanUpCart.mock
}

// Set uses given function f to mock the Repository.CleanUpCart method
func (mmCleanUpCart *mRepositoryMockCleanUpCart) Set(f func(ctx context.Context, userID int64) (err error)) *RepositoryMock {
	if mmCleanUpCart.defaultExpectation != nil {
		mmCleanUpCart.mock.t.Fatalf("Default expectation is already set for the Repository.CleanUpCart method")
	}

	if len(mmCleanUpCart.expectations) > 0 {
		mmCleanUpCart.mock.t.Fatalf("Some expectations are already set for the Repository.CleanUpCart method")
	}

	mmCleanUpCart.mock.funcCleanUpCart = f
	return mmCleanUpCart.mock
}

// When sets expectation for the Repository.CleanUpCart which will trigger the result defined by the following
// Then helper
func (mmCleanUpCart *mRepositoryMockCleanUpCart) When(ctx context.Context, userID int64) *RepositoryMockCleanUpCartExpectation {
	if mmCleanUpCart.mock.funcCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("RepositoryMock.CleanUpCart mock is already set by Set")
	}

	expectation := &RepositoryMockCleanUpCartExpectation{
		mock:   mmCleanUpCart.mock,
		params: &RepositoryMockCleanUpCartParams{ctx, userID},
	}
	mmCleanUpCart.expectations = append(mmCleanUpCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.CleanUpCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCleanUpCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCleanUpCartResults{err}
	return e.mock
}

// CleanUpCart implements Repository
func (mmCleanUpCart *RepositoryMock) CleanUpCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmCleanUpCart.beforeCleanUpCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanUpCart.afterCleanUpCartCounter, 1)

	if mmCleanUpCart.inspectFuncCleanUpCart != nil {
		mmCleanUpCart.inspectFuncCleanUpCart(ctx, userID)
	}

	mm_params := RepositoryMockCleanUpCartParams{ctx, userID}

	// Record call args
	mmCleanUpCart.CleanUpCartMock.mutex.Lock()
	mmCleanUpCart.CleanUpCartMock.callArgs = append(mmCleanUpCart.CleanUpCartMock.callArgs, &mm_params)
	mmCleanUpCart.CleanUpCartMock.mutex.Unlock()

	for _, e := range mmCleanUpCart.CleanUpCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanUpCart.CleanUpCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanUpCart.CleanUpCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanUpCart.CleanUpCartMock.defaultExpectation.params
		mm_got := RepositoryMockCleanUpCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanUpCart.t.Errorf("RepositoryMock.CleanUpCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanUpCart.CleanUpCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanUpCart.t.Fatal("No results are set for the RepositoryMock.CleanUpCart")
		}
		return (*mm_results).err
	}
	if mmCleanUpCart.funcCleanUpCart != nil {
		return mmCleanUpCart.funcCleanUpCart(ctx, userID)
	}
	mmCleanUpCart.t.Fatalf("Unexpected call to RepositoryMock.CleanUpCart. %v %v", ctx, userID)
	return
}

// CleanUpCartAfterCounter returns a count of finished RepositoryMock.CleanUpCart invocations
func (mmCleanUpCart *RepositoryMock) CleanUpCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanUpCart.afterCleanUpCartCounter)
}

// CleanUpCartBeforeCounter returns a count of RepositoryMock.CleanUpCart invocations
func (mmCleanUpCart *RepositoryMock) CleanUpCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanUpCart.beforeCleanUpCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CleanUpCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanUpCart *mRepositoryMockCleanUpCart) Calls() []*RepositoryMockCleanUpCartParams {
	mmCleanUpCart.mutex.RLock()

	argCopy := make([]*RepositoryMockCleanUpCartParams, len(mmCleanUpCart.callArgs))
	copy(argCopy, mmCleanUpCart.callArgs)

	mmCleanUpCart.mutex.RUnlock()

	return argCopy
}

// MinimockCleanUpCartDone returns true if the count of the CleanUpCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCleanUpCartDone() bool {
	for _, e := range m.CleanUpCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanUpCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanUpCart != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockCleanUpCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCleanUpCartInspect() {
	for _, e := range m.CleanUpCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CleanUpCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanUpCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		if m.CleanUpCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CleanUpCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CleanUpCart with params: %#v", *m.CleanUpCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanUpCart != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CleanUpCart")
	}
}

type mRepositoryMockCreateCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCartExpectation
	expectations       []*RepositoryMockCreateCartExpectation

	callArgs []*RepositoryMockCreateCartParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateCartExpectation specifies expectation struct of the Repository.CreateCart
type RepositoryMockCreateCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateCartParams
	results *RepositoryMockCreateCartResults
	Counter uint64
}

// RepositoryMockCreateCartParams contains parameters of the Repository.CreateCart
type RepositoryMockCreateCartParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockCreateCartResults contains results of the Repository.CreateCart
type RepositoryMockCreateCartResults struct {
	c2  model.Cart
	err error
}

// Expect sets up expected params for Repository.CreateCart
func (mmCreateCart *mRepositoryMockCreateCart) Expect(ctx context.Context, userID int64) *mRepositoryMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("RepositoryMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &RepositoryMockCreateCartExpectation{}
	}

	mmCreateCart.defaultExpectation.params = &RepositoryMockCreateCartParams{ctx, userID}
	for _, e := range mmCreateCart.expectations {
		if minimock.Equal(e.params, mmCreateCart.defaultExpectation.params) {
			mmCreateCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCart.defaultExpectation.params)
		}
	}

	return mmCreateCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateCart
func (mmCreateCart *mRepositoryMockCreateCart) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockCreateCart {
	if mmCreateCart.mock.inspectFuncCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateCart")
	}

	mmCreateCart.mock.inspectFuncCreateCart = f

	return mmCreateCart
}

// Return sets up results that will be returned by Repository.CreateCart
func (mmCreateCart *mRepositoryMockCreateCart) Return(c2 model.Cart, err error) *RepositoryMock {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("RepositoryMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &RepositoryMockCreateCartExpectation{mock: mmCreateCart.mock}
	}
	mmCreateCart.defaultExpectation.results = &RepositoryMockCreateCartResults{c2, err}
	return mmCreateCart.mock
}

// Set uses given function f to mock the Repository.CreateCart method
func (mmCreateCart *mRepositoryMockCreateCart) Set(f func(ctx context.Context, userID int64) (c2 model.Cart, err error)) *RepositoryMock {
	if mmCreateCart.defaultExpectation != nil {
		mmCreateCart.mock.t.Fatalf("Default expectation is already set for the Repository.CreateCart method")
	}

	if len(mmCreateCart.expectations) > 0 {
		mmCreateCart.mock.t.Fatalf("Some expectations are already set for the Repository.CreateCart method")
	}

	mmCreateCart.mock.funcCreateCart = f
	return mmCreateCart.mock
}

// When sets expectation for the Repository.CreateCart which will trigger the result defined by the following
// Then helper
func (mmCreateCart *mRepositoryMockCreateCart) When(ctx context.Context, userID int64) *RepositoryMockCreateCartExpectation {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("RepositoryMock.CreateCart mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCartExpectation{
		mock:   mmCreateCart.mock,
		params: &RepositoryMockCreateCartParams{ctx, userID},
	}
	mmCreateCart.expectations = append(mmCreateCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCartExpectation) Then(c2 model.Cart, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCartResults{c2, err}
	return e.mock
}

// CreateCart implements Repository
func (mmCreateCart *RepositoryMock) CreateCart(ctx context.Context, userID int64) (c2 model.Cart, err error) {
	mm_atomic.AddUint64(&mmCreateCart.beforeCreateCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCart.afterCreateCartCounter, 1)

	if mmCreateCart.inspectFuncCreateCart != nil {
		mmCreateCart.inspectFuncCreateCart(ctx, userID)
	}

	mm_params := RepositoryMockCreateCartParams{ctx, userID}

	// Record call args
	mmCreateCart.CreateCartMock.mutex.Lock()
	mmCreateCart.CreateCartMock.callArgs = append(mmCreateCart.CreateCartMock.callArgs, &mm_params)
	mmCreateCart.CreateCartMock.mutex.Unlock()

	for _, e := range mmCreateCart.CreateCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmCreateCart.CreateCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCart.CreateCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCart.CreateCartMock.defaultExpectation.params
		mm_got := RepositoryMockCreateCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCart.t.Errorf("RepositoryMock.CreateCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCart.CreateCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCart.t.Fatal("No results are set for the RepositoryMock.CreateCart")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmCreateCart.funcCreateCart != nil {
		return mmCreateCart.funcCreateCart(ctx, userID)
	}
	mmCreateCart.t.Fatalf("Unexpected call to RepositoryMock.CreateCart. %v %v", ctx, userID)
	return
}

// CreateCartAfterCounter returns a count of finished RepositoryMock.CreateCart invocations
func (mmCreateCart *RepositoryMock) CreateCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCart.afterCreateCartCounter)
}

// CreateCartBeforeCounter returns a count of RepositoryMock.CreateCart invocations
func (mmCreateCart *RepositoryMock) CreateCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCart.beforeCreateCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCart *mRepositoryMockCreateCart) Calls() []*RepositoryMockCreateCartParams {
	mmCreateCart.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCartParams, len(mmCreateCart.callArgs))
	copy(argCopy, mmCreateCart.callArgs)

	mmCreateCart.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartDone returns true if the count of the CreateCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCartDone() bool {
	for _, e := range m.CreateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCart != nil && mm_atomic.LoadUint64(&m.afterCreateCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCartInspect() {
	for _, e := range m.CreateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartCounter) < 1 {
		if m.CreateCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateCart with params: %#v", *m.CreateCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCart != nil && mm_atomic.LoadUint64(&m.afterCreateCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateCart")
	}
}

type mRepositoryMockGetCartByUserID struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCartByUserIDExpectation
	expectations       []*RepositoryMockGetCartByUserIDExpectation

	callArgs []*RepositoryMockGetCartByUserIDParams
	mutex    sync.RWMutex
}

// RepositoryMockGetCartByUserIDExpectation specifies expectation struct of the Repository.GetCartByUserID
type RepositoryMockGetCartByUserIDExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetCartByUserIDParams
	results *RepositoryMockGetCartByUserIDResults
	Counter uint64
}

// RepositoryMockGetCartByUserIDParams contains parameters of the Repository.GetCartByUserID
type RepositoryMockGetCartByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockGetCartByUserIDResults contains results of the Repository.GetCartByUserID
type RepositoryMockGetCartByUserIDResults struct {
	c2  model.Cart
	err error
}

// Expect sets up expected params for Repository.GetCartByUserID
func (mmGetCartByUserID *mRepositoryMockGetCartByUserID) Expect(ctx context.Context, userID int64) *mRepositoryMockGetCartByUserID {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("RepositoryMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &RepositoryMockGetCartByUserIDExpectation{}
	}

	mmGetCartByUserID.defaultExpectation.params = &RepositoryMockGetCartByUserIDParams{ctx, userID}
	for _, e := range mmGetCartByUserID.expectations {
		if minimock.Equal(e.params, mmGetCartByUserID.defaultExpectation.params) {
			mmGetCartByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartByUserID.defaultExpectation.params)
		}
	}

	return mmGetCartByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCartByUserID
func (mmGetCartByUserID *mRepositoryMockGetCartByUserID) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockGetCartByUserID {
	if mmGetCartByUserID.mock.inspectFuncGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCartByUserID")
	}

	mmGetCartByUserID.mock.inspectFuncGetCartByUserID = f

	return mmGetCartByUserID
}

// Return sets up results that will be returned by Repository.GetCartByUserID
func (mmGetCartByUserID *mRepositoryMockGetCartByUserID) Return(c2 model.Cart, err error) *RepositoryMock {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("RepositoryMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &RepositoryMockGetCartByUserIDExpectation{mock: mmGetCartByUserID.mock}
	}
	mmGetCartByUserID.defaultExpectation.results = &RepositoryMockGetCartByUserIDResults{c2, err}
	return mmGetCartByUserID.mock
}

// Set uses given function f to mock the Repository.GetCartByUserID method
func (mmGetCartByUserID *mRepositoryMockGetCartByUserID) Set(f func(ctx context.Context, userID int64) (c2 model.Cart, err error)) *RepositoryMock {
	if mmGetCartByUserID.defaultExpectation != nil {
		mmGetCartByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.GetCartByUserID method")
	}

	if len(mmGetCartByUserID.expectations) > 0 {
		mmGetCartByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.GetCartByUserID method")
	}

	mmGetCartByUserID.mock.funcGetCartByUserID = f
	return mmGetCartByUserID.mock
}

// When sets expectation for the Repository.GetCartByUserID which will trigger the result defined by the following
// Then helper
func (mmGetCartByUserID *mRepositoryMockGetCartByUserID) When(ctx context.Context, userID int64) *RepositoryMockGetCartByUserIDExpectation {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("RepositoryMock.GetCartByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockGetCartByUserIDExpectation{
		mock:   mmGetCartByUserID.mock,
		params: &RepositoryMockGetCartByUserIDParams{ctx, userID},
	}
	mmGetCartByUserID.expectations = append(mmGetCartByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCartByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCartByUserIDExpectation) Then(c2 model.Cart, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCartByUserIDResults{c2, err}
	return e.mock
}

// GetCartByUserID implements Repository
func (mmGetCartByUserID *RepositoryMock) GetCartByUserID(ctx context.Context, userID int64) (c2 model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCartByUserID.beforeGetCartByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartByUserID.afterGetCartByUserIDCounter, 1)

	if mmGetCartByUserID.inspectFuncGetCartByUserID != nil {
		mmGetCartByUserID.inspectFuncGetCartByUserID(ctx, userID)
	}

	mm_params := RepositoryMockGetCartByUserIDParams{ctx, userID}

	// Record call args
	mmGetCartByUserID.GetCartByUserIDMock.mutex.Lock()
	mmGetCartByUserID.GetCartByUserIDMock.callArgs = append(mmGetCartByUserID.GetCartByUserIDMock.callArgs, &mm_params)
	mmGetCartByUserID.GetCartByUserIDMock.mutex.Unlock()

	for _, e := range mmGetCartByUserID.GetCartByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.params
		mm_got := RepositoryMockGetCartByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartByUserID.t.Errorf("RepositoryMock.GetCartByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartByUserID.t.Fatal("No results are set for the RepositoryMock.GetCartByUserID")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCartByUserID.funcGetCartByUserID != nil {
		return mmGetCartByUserID.funcGetCartByUserID(ctx, userID)
	}
	mmGetCartByUserID.t.Fatalf("Unexpected call to RepositoryMock.GetCartByUserID. %v %v", ctx, userID)
	return
}

// GetCartByUserIDAfterCounter returns a count of finished RepositoryMock.GetCartByUserID invocations
func (mmGetCartByUserID *RepositoryMock) GetCartByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserID.afterGetCartByUserIDCounter)
}

// GetCartByUserIDBeforeCounter returns a count of RepositoryMock.GetCartByUserID invocations
func (mmGetCartByUserID *RepositoryMock) GetCartByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserID.beforeGetCartByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCartByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartByUserID *mRepositoryMockGetCartByUserID) Calls() []*RepositoryMockGetCartByUserIDParams {
	mmGetCartByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCartByUserIDParams, len(mmGetCartByUserID.callArgs))
	copy(argCopy, mmGetCartByUserID.callArgs)

	mmGetCartByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartByUserIDDone returns true if the count of the GetCartByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCartByUserIDDone() bool {
	for _, e := range m.GetCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartByUserID != nil && mm_atomic.LoadUint64(&m.afterGetCartByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCartByUserIDInspect() {
	for _, e := range m.GetCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCartByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartByUserIDCounter) < 1 {
		if m.GetCartByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetCartByUserID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCartByUserID with params: %#v", *m.GetCartByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartByUserID != nil && mm_atomic.LoadUint64(&m.afterGetCartByUserIDCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCartByUserID")
	}
}

type mRepositoryMockRemoveGoodFromCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockRemoveGoodFromCartExpectation
	expectations       []*RepositoryMockRemoveGoodFromCartExpectation

	callArgs []*RepositoryMockRemoveGoodFromCartParams
	mutex    sync.RWMutex
}

// RepositoryMockRemoveGoodFromCartExpectation specifies expectation struct of the Repository.RemoveGoodFromCart
type RepositoryMockRemoveGoodFromCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockRemoveGoodFromCartParams
	results *RepositoryMockRemoveGoodFromCartResults
	Counter uint64
}

// RepositoryMockRemoveGoodFromCartParams contains parameters of the Repository.RemoveGoodFromCart
type RepositoryMockRemoveGoodFromCartParams struct {
	ctx    context.Context
	userID int64
	skuID  uint32
}

// RepositoryMockRemoveGoodFromCartResults contains results of the Repository.RemoveGoodFromCart
type RepositoryMockRemoveGoodFromCartResults struct {
	err error
}

// Expect sets up expected params for Repository.RemoveGoodFromCart
func (mmRemoveGoodFromCart *mRepositoryMockRemoveGoodFromCart) Expect(ctx context.Context, userID int64, skuID uint32) *mRepositoryMockRemoveGoodFromCart {
	if mmRemoveGoodFromCart.mock.funcRemoveGoodFromCart != nil {
		mmRemoveGoodFromCart.mock.t.Fatalf("RepositoryMock.RemoveGoodFromCart mock is already set by Set")
	}

	if mmRemoveGoodFromCart.defaultExpectation == nil {
		mmRemoveGoodFromCart.defaultExpectation = &RepositoryMockRemoveGoodFromCartExpectation{}
	}

	mmRemoveGoodFromCart.defaultExpectation.params = &RepositoryMockRemoveGoodFromCartParams{ctx, userID, skuID}
	for _, e := range mmRemoveGoodFromCart.expectations {
		if minimock.Equal(e.params, mmRemoveGoodFromCart.defaultExpectation.params) {
			mmRemoveGoodFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveGoodFromCart.defaultExpectation.params)
		}
	}

	return mmRemoveGoodFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.RemoveGoodFromCart
func (mmRemoveGoodFromCart *mRepositoryMockRemoveGoodFromCart) Inspect(f func(ctx context.Context, userID int64, skuID uint32)) *mRepositoryMockRemoveGoodFromCart {
	if mmRemoveGoodFromCart.mock.inspectFuncRemoveGoodFromCart != nil {
		mmRemoveGoodFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.RemoveGoodFromCart")
	}

	mmRemoveGoodFromCart.mock.inspectFuncRemoveGoodFromCart = f

	return mmRemoveGoodFromCart
}

// Return sets up results that will be returned by Repository.RemoveGoodFromCart
func (mmRemoveGoodFromCart *mRepositoryMockRemoveGoodFromCart) Return(err error) *RepositoryMock {
	if mmRemoveGoodFromCart.mock.funcRemoveGoodFromCart != nil {
		mmRemoveGoodFromCart.mock.t.Fatalf("RepositoryMock.RemoveGoodFromCart mock is already set by Set")
	}

	if mmRemoveGoodFromCart.defaultExpectation == nil {
		mmRemoveGoodFromCart.defaultExpectation = &RepositoryMockRemoveGoodFromCartExpectation{mock: mmRemoveGoodFromCart.mock}
	}
	mmRemoveGoodFromCart.defaultExpectation.results = &RepositoryMockRemoveGoodFromCartResults{err}
	return mmRemoveGoodFromCart.mock
}

// Set uses given function f to mock the Repository.RemoveGoodFromCart method
func (mmRemoveGoodFromCart *mRepositoryMockRemoveGoodFromCart) Set(f func(ctx context.Context, userID int64, skuID uint32) (err error)) *RepositoryMock {
	if mmRemoveGoodFromCart.defaultExpectation != nil {
		mmRemoveGoodFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.RemoveGoodFromCart method")
	}

	if len(mmRemoveGoodFromCart.expectations) > 0 {
		mmRemoveGoodFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.RemoveGoodFromCart method")
	}

	mmRemoveGoodFromCart.mock.funcRemoveGoodFromCart = f
	return mmRemoveGoodFromCart.mock
}

// When sets expectation for the Repository.RemoveGoodFromCart which will trigger the result defined by the following
// Then helper
func (mmRemoveGoodFromCart *mRepositoryMockRemoveGoodFromCart) When(ctx context.Context, userID int64, skuID uint32) *RepositoryMockRemoveGoodFromCartExpectation {
	if mmRemoveGoodFromCart.mock.funcRemoveGoodFromCart != nil {
		mmRemoveGoodFromCart.mock.t.Fatalf("RepositoryMock.RemoveGoodFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockRemoveGoodFromCartExpectation{
		mock:   mmRemoveGoodFromCart.mock,
		params: &RepositoryMockRemoveGoodFromCartParams{ctx, userID, skuID},
	}
	mmRemoveGoodFromCart.expectations = append(mmRemoveGoodFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.RemoveGoodFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockRemoveGoodFromCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockRemoveGoodFromCartResults{err}
	return e.mock
}

// RemoveGoodFromCart implements Repository
func (mmRemoveGoodFromCart *RepositoryMock) RemoveGoodFromCart(ctx context.Context, userID int64, skuID uint32) (err error) {
	mm_atomic.AddUint64(&mmRemoveGoodFromCart.beforeRemoveGoodFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveGoodFromCart.afterRemoveGoodFromCartCounter, 1)

	if mmRemoveGoodFromCart.inspectFuncRemoveGoodFromCart != nil {
		mmRemoveGoodFromCart.inspectFuncRemoveGoodFromCart(ctx, userID, skuID)
	}

	mm_params := RepositoryMockRemoveGoodFromCartParams{ctx, userID, skuID}

	// Record call args
	mmRemoveGoodFromCart.RemoveGoodFromCartMock.mutex.Lock()
	mmRemoveGoodFromCart.RemoveGoodFromCartMock.callArgs = append(mmRemoveGoodFromCart.RemoveGoodFromCartMock.callArgs, &mm_params)
	mmRemoveGoodFromCart.RemoveGoodFromCartMock.mutex.Unlock()

	for _, e := range mmRemoveGoodFromCart.RemoveGoodFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveGoodFromCart.RemoveGoodFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveGoodFromCart.RemoveGoodFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveGoodFromCart.RemoveGoodFromCartMock.defaultExpectation.params
		mm_got := RepositoryMockRemoveGoodFromCartParams{ctx, userID, skuID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveGoodFromCart.t.Errorf("RepositoryMock.RemoveGoodFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveGoodFromCart.RemoveGoodFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveGoodFromCart.t.Fatal("No results are set for the RepositoryMock.RemoveGoodFromCart")
		}
		return (*mm_results).err
	}
	if mmRemoveGoodFromCart.funcRemoveGoodFromCart != nil {
		return mmRemoveGoodFromCart.funcRemoveGoodFromCart(ctx, userID, skuID)
	}
	mmRemoveGoodFromCart.t.Fatalf("Unexpected call to RepositoryMock.RemoveGoodFromCart. %v %v %v", ctx, userID, skuID)
	return
}

// RemoveGoodFromCartAfterCounter returns a count of finished RepositoryMock.RemoveGoodFromCart invocations
func (mmRemoveGoodFromCart *RepositoryMock) RemoveGoodFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveGoodFromCart.afterRemoveGoodFromCartCounter)
}

// RemoveGoodFromCartBeforeCounter returns a count of RepositoryMock.RemoveGoodFromCart invocations
func (mmRemoveGoodFromCart *RepositoryMock) RemoveGoodFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveGoodFromCart.beforeRemoveGoodFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.RemoveGoodFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveGoodFromCart *mRepositoryMockRemoveGoodFromCart) Calls() []*RepositoryMockRemoveGoodFromCartParams {
	mmRemoveGoodFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockRemoveGoodFromCartParams, len(mmRemoveGoodFromCart.callArgs))
	copy(argCopy, mmRemoveGoodFromCart.callArgs)

	mmRemoveGoodFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveGoodFromCartDone returns true if the count of the RemoveGoodFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockRemoveGoodFromCartDone() bool {
	for _, e := range m.RemoveGoodFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveGoodFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveGoodFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveGoodFromCart != nil && mm_atomic.LoadUint64(&m.afterRemoveGoodFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveGoodFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockRemoveGoodFromCartInspect() {
	for _, e := range m.RemoveGoodFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.RemoveGoodFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveGoodFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveGoodFromCartCounter) < 1 {
		if m.RemoveGoodFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.RemoveGoodFromCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.RemoveGoodFromCart with params: %#v", *m.RemoveGoodFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveGoodFromCart != nil && mm_atomic.LoadUint64(&m.afterRemoveGoodFromCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.RemoveGoodFromCart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddGoodToCartInspect()

			m.MinimockCleanUpCartInspect()

			m.MinimockCreateCartInspect()

			m.MinimockGetCartByUserIDInspect()

			m.MinimockRemoveGoodFromCartInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddGoodToCartDone() &&
		m.MinimockCleanUpCartDone() &&
		m.MinimockCreateCartDone() &&
		m.MinimockGetCartByUserIDDone() &&
		m.MinimockRemoveGoodFromCartDone()
}
