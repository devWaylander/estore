// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package service

//go:generate minimock -i route256.ozon.ru/project/cart/internal/handler.Service -o service_mock_test.go -n ServiceMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/cart/internal/model"
)

// ServiceMock implements handler.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddToCart          func(ctx context.Context, userID int64, skuID int64, count uint16) (err error)
	inspectFuncAddToCart   func(ctx context.Context, userID int64, skuID int64, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mServiceMockAddToCart

	funcCleanUpCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncCleanUpCart   func(ctx context.Context, userID int64)
	afterCleanUpCartCounter  uint64
	beforeCleanUpCartCounter uint64
	CleanUpCartMock          mServiceMockCleanUpCart

	funcGetCart          func(ctx context.Context, userID int64) (cp1 *model.Cart, err error)
	inspectFuncGetCart   func(ctx context.Context, userID int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mServiceMockGetCart

	funcRemoveFromCart          func(ctx context.Context, userID int64, skuID int64) (err error)
	inspectFuncRemoveFromCart   func(ctx context.Context, userID int64, skuID int64)
	afterRemoveFromCartCounter  uint64
	beforeRemoveFromCartCounter uint64
	RemoveFromCartMock          mServiceMockRemoveFromCart
}

// NewServiceMock returns a mock for handler.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mServiceMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*ServiceMockAddToCartParams{}

	m.CleanUpCartMock = mServiceMockCleanUpCart{mock: m}
	m.CleanUpCartMock.callArgs = []*ServiceMockCleanUpCartParams{}

	m.GetCartMock = mServiceMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*ServiceMockGetCartParams{}

	m.RemoveFromCartMock = mServiceMockRemoveFromCart{mock: m}
	m.RemoveFromCartMock.callArgs = []*ServiceMockRemoveFromCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockAddToCart struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockAddToCartExpectation
	expectations       []*ServiceMockAddToCartExpectation

	callArgs []*ServiceMockAddToCartParams
	mutex    sync.RWMutex
}

// ServiceMockAddToCartExpectation specifies expectation struct of the Service.AddToCart
type ServiceMockAddToCartExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockAddToCartParams
	results *ServiceMockAddToCartResults
	Counter uint64
}

// ServiceMockAddToCartParams contains parameters of the Service.AddToCart
type ServiceMockAddToCartParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
	count  uint16
}

// ServiceMockAddToCartResults contains results of the Service.AddToCart
type ServiceMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for Service.AddToCart
func (mmAddToCart *mServiceMockAddToCart) Expect(ctx context.Context, userID int64, skuID int64, count uint16) *mServiceMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("ServiceMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &ServiceMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &ServiceMockAddToCartParams{ctx, userID, skuID, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the Service.AddToCart
func (mmAddToCart *mServiceMockAddToCart) Inspect(f func(ctx context.Context, userID int64, skuID int64, count uint16)) *mServiceMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for ServiceMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by Service.AddToCart
func (mmAddToCart *mServiceMockAddToCart) Return(err error) *ServiceMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("ServiceMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &ServiceMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &ServiceMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the Service.AddToCart method
func (mmAddToCart *mServiceMockAddToCart) Set(f func(ctx context.Context, userID int64, skuID int64, count uint16) (err error)) *ServiceMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the Service.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the Service.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the Service.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mServiceMockAddToCart) When(ctx context.Context, userID int64, skuID int64, count uint16) *ServiceMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("ServiceMock.AddToCart mock is already set by Set")
	}

	expectation := &ServiceMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &ServiceMockAddToCartParams{ctx, userID, skuID, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up Service.AddToCart return parameters for the expectation previously defined by the When method
func (e *ServiceMockAddToCartExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements handler.Service
func (mmAddToCart *ServiceMock) AddToCart(ctx context.Context, userID int64, skuID int64, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, userID, skuID, count)
	}

	mm_params := ServiceMockAddToCartParams{ctx, userID, skuID, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, &mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := ServiceMockAddToCartParams{ctx, userID, skuID, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("ServiceMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the ServiceMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, userID, skuID, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to ServiceMock.AddToCart. %v %v %v %v", ctx, userID, skuID, count)
	return
}

// AddToCartAfterCounter returns a count of finished ServiceMock.AddToCart invocations
func (mmAddToCart *ServiceMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of ServiceMock.AddToCart invocations
func (mmAddToCart *ServiceMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mServiceMockAddToCart) Calls() []*ServiceMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*ServiceMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *ServiceMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to ServiceMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.AddToCart")
	}
}

type mServiceMockCleanUpCart struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanUpCartExpectation
	expectations       []*ServiceMockCleanUpCartExpectation

	callArgs []*ServiceMockCleanUpCartParams
	mutex    sync.RWMutex
}

// ServiceMockCleanUpCartExpectation specifies expectation struct of the Service.CleanUpCart
type ServiceMockCleanUpCartExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCleanUpCartParams
	results *ServiceMockCleanUpCartResults
	Counter uint64
}

// ServiceMockCleanUpCartParams contains parameters of the Service.CleanUpCart
type ServiceMockCleanUpCartParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockCleanUpCartResults contains results of the Service.CleanUpCart
type ServiceMockCleanUpCartResults struct {
	err error
}

// Expect sets up expected params for Service.CleanUpCart
func (mmCleanUpCart *mServiceMockCleanUpCart) Expect(ctx context.Context, userID int64) *mServiceMockCleanUpCart {
	if mmCleanUpCart.mock.funcCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("ServiceMock.CleanUpCart mock is already set by Set")
	}

	if mmCleanUpCart.defaultExpectation == nil {
		mmCleanUpCart.defaultExpectation = &ServiceMockCleanUpCartExpectation{}
	}

	mmCleanUpCart.defaultExpectation.params = &ServiceMockCleanUpCartParams{ctx, userID}
	for _, e := range mmCleanUpCart.expectations {
		if minimock.Equal(e.params, mmCleanUpCart.defaultExpectation.params) {
			mmCleanUpCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanUpCart.defaultExpectation.params)
		}
	}

	return mmCleanUpCart
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanUpCart
func (mmCleanUpCart *mServiceMockCleanUpCart) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockCleanUpCart {
	if mmCleanUpCart.mock.inspectFuncCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanUpCart")
	}

	mmCleanUpCart.mock.inspectFuncCleanUpCart = f

	return mmCleanUpCart
}

// Return sets up results that will be returned by Service.CleanUpCart
func (mmCleanUpCart *mServiceMockCleanUpCart) Return(err error) *ServiceMock {
	if mmCleanUpCart.mock.funcCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("ServiceMock.CleanUpCart mock is already set by Set")
	}

	if mmCleanUpCart.defaultExpectation == nil {
		mmCleanUpCart.defaultExpectation = &ServiceMockCleanUpCartExpectation{mock: mmCleanUpCart.mock}
	}
	mmCleanUpCart.defaultExpectation.results = &ServiceMockCleanUpCartResults{err}
	return mmCleanUpCart.mock
}

// Set uses given function f to mock the Service.CleanUpCart method
func (mmCleanUpCart *mServiceMockCleanUpCart) Set(f func(ctx context.Context, userID int64) (err error)) *ServiceMock {
	if mmCleanUpCart.defaultExpectation != nil {
		mmCleanUpCart.mock.t.Fatalf("Default expectation is already set for the Service.CleanUpCart method")
	}

	if len(mmCleanUpCart.expectations) > 0 {
		mmCleanUpCart.mock.t.Fatalf("Some expectations are already set for the Service.CleanUpCart method")
	}

	mmCleanUpCart.mock.funcCleanUpCart = f
	return mmCleanUpCart.mock
}

// When sets expectation for the Service.CleanUpCart which will trigger the result defined by the following
// Then helper
func (mmCleanUpCart *mServiceMockCleanUpCart) When(ctx context.Context, userID int64) *ServiceMockCleanUpCartExpectation {
	if mmCleanUpCart.mock.funcCleanUpCart != nil {
		mmCleanUpCart.mock.t.Fatalf("ServiceMock.CleanUpCart mock is already set by Set")
	}

	expectation := &ServiceMockCleanUpCartExpectation{
		mock:   mmCleanUpCart.mock,
		params: &ServiceMockCleanUpCartParams{ctx, userID},
	}
	mmCleanUpCart.expectations = append(mmCleanUpCart.expectations, expectation)
	return expectation
}

// Then sets up Service.CleanUpCart return parameters for the expectation previously defined by the When method
func (e *ServiceMockCleanUpCartExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCleanUpCartResults{err}
	return e.mock
}

// CleanUpCart implements handler.Service
func (mmCleanUpCart *ServiceMock) CleanUpCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmCleanUpCart.beforeCleanUpCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanUpCart.afterCleanUpCartCounter, 1)

	if mmCleanUpCart.inspectFuncCleanUpCart != nil {
		mmCleanUpCart.inspectFuncCleanUpCart(ctx, userID)
	}

	mm_params := ServiceMockCleanUpCartParams{ctx, userID}

	// Record call args
	mmCleanUpCart.CleanUpCartMock.mutex.Lock()
	mmCleanUpCart.CleanUpCartMock.callArgs = append(mmCleanUpCart.CleanUpCartMock.callArgs, &mm_params)
	mmCleanUpCart.CleanUpCartMock.mutex.Unlock()

	for _, e := range mmCleanUpCart.CleanUpCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanUpCart.CleanUpCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanUpCart.CleanUpCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanUpCart.CleanUpCartMock.defaultExpectation.params
		mm_got := ServiceMockCleanUpCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanUpCart.t.Errorf("ServiceMock.CleanUpCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanUpCart.CleanUpCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanUpCart.t.Fatal("No results are set for the ServiceMock.CleanUpCart")
		}
		return (*mm_results).err
	}
	if mmCleanUpCart.funcCleanUpCart != nil {
		return mmCleanUpCart.funcCleanUpCart(ctx, userID)
	}
	mmCleanUpCart.t.Fatalf("Unexpected call to ServiceMock.CleanUpCart. %v %v", ctx, userID)
	return
}

// CleanUpCartAfterCounter returns a count of finished ServiceMock.CleanUpCart invocations
func (mmCleanUpCart *ServiceMock) CleanUpCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanUpCart.afterCleanUpCartCounter)
}

// CleanUpCartBeforeCounter returns a count of ServiceMock.CleanUpCart invocations
func (mmCleanUpCart *ServiceMock) CleanUpCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanUpCart.beforeCleanUpCartCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CleanUpCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanUpCart *mServiceMockCleanUpCart) Calls() []*ServiceMockCleanUpCartParams {
	mmCleanUpCart.mutex.RLock()

	argCopy := make([]*ServiceMockCleanUpCartParams, len(mmCleanUpCart.callArgs))
	copy(argCopy, mmCleanUpCart.callArgs)

	mmCleanUpCart.mutex.RUnlock()

	return argCopy
}

// MinimockCleanUpCartDone returns true if the count of the CleanUpCart invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanUpCartDone() bool {
	for _, e := range m.CleanUpCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanUpCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanUpCart != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockCleanUpCartInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanUpCartInspect() {
	for _, e := range m.CleanUpCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CleanUpCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanUpCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		if m.CleanUpCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CleanUpCart")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CleanUpCart with params: %#v", *m.CleanUpCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanUpCart != nil && mm_atomic.LoadUint64(&m.afterCleanUpCartCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CleanUpCart")
	}
}

type mServiceMockGetCart struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetCartExpectation
	expectations       []*ServiceMockGetCartExpectation

	callArgs []*ServiceMockGetCartParams
	mutex    sync.RWMutex
}

// ServiceMockGetCartExpectation specifies expectation struct of the Service.GetCart
type ServiceMockGetCartExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockGetCartParams
	results *ServiceMockGetCartResults
	Counter uint64
}

// ServiceMockGetCartParams contains parameters of the Service.GetCart
type ServiceMockGetCartParams struct {
	ctx    context.Context
	userID int64
}

// ServiceMockGetCartResults contains results of the Service.GetCart
type ServiceMockGetCartResults struct {
	cp1 *model.Cart
	err error
}

// Expect sets up expected params for Service.GetCart
func (mmGetCart *mServiceMockGetCart) Expect(ctx context.Context, userID int64) *mServiceMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("ServiceMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &ServiceMockGetCartExpectation{}
	}

	mmGetCart.defaultExpectation.params = &ServiceMockGetCartParams{ctx, userID}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the Service.GetCart
func (mmGetCart *mServiceMockGetCart) Inspect(f func(ctx context.Context, userID int64)) *mServiceMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by Service.GetCart
func (mmGetCart *mServiceMockGetCart) Return(cp1 *model.Cart, err error) *ServiceMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("ServiceMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &ServiceMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &ServiceMockGetCartResults{cp1, err}
	return mmGetCart.mock
}

// Set uses given function f to mock the Service.GetCart method
func (mmGetCart *mServiceMockGetCart) Set(f func(ctx context.Context, userID int64) (cp1 *model.Cart, err error)) *ServiceMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the Service.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the Service.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the Service.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mServiceMockGetCart) When(ctx context.Context, userID int64) *ServiceMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("ServiceMock.GetCart mock is already set by Set")
	}

	expectation := &ServiceMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &ServiceMockGetCartParams{ctx, userID},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up Service.GetCart return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetCartExpectation) Then(cp1 *model.Cart, err error) *ServiceMock {
	e.results = &ServiceMockGetCartResults{cp1, err}
	return e.mock
}

// GetCart implements handler.Service
func (mmGetCart *ServiceMock) GetCart(ctx context.Context, userID int64) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userID)
	}

	mm_params := ServiceMockGetCartParams{ctx, userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_got := ServiceMockGetCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("ServiceMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the ServiceMock.GetCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to ServiceMock.GetCart. %v %v", ctx, userID)
	return
}

// GetCartAfterCounter returns a count of finished ServiceMock.GetCart invocations
func (mmGetCart *ServiceMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of ServiceMock.GetCart invocations
func (mmGetCart *ServiceMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mServiceMockGetCart) Calls() []*ServiceMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*ServiceMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetCartDone() bool {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GetCart")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.GetCart")
	}
}

type mServiceMockRemoveFromCart struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockRemoveFromCartExpectation
	expectations       []*ServiceMockRemoveFromCartExpectation

	callArgs []*ServiceMockRemoveFromCartParams
	mutex    sync.RWMutex
}

// ServiceMockRemoveFromCartExpectation specifies expectation struct of the Service.RemoveFromCart
type ServiceMockRemoveFromCartExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockRemoveFromCartParams
	results *ServiceMockRemoveFromCartResults
	Counter uint64
}

// ServiceMockRemoveFromCartParams contains parameters of the Service.RemoveFromCart
type ServiceMockRemoveFromCartParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
}

// ServiceMockRemoveFromCartResults contains results of the Service.RemoveFromCart
type ServiceMockRemoveFromCartResults struct {
	err error
}

// Expect sets up expected params for Service.RemoveFromCart
func (mmRemoveFromCart *mServiceMockRemoveFromCart) Expect(ctx context.Context, userID int64, skuID int64) *mServiceMockRemoveFromCart {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("ServiceMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &ServiceMockRemoveFromCartExpectation{}
	}

	mmRemoveFromCart.defaultExpectation.params = &ServiceMockRemoveFromCartParams{ctx, userID, skuID}
	for _, e := range mmRemoveFromCart.expectations {
		if minimock.Equal(e.params, mmRemoveFromCart.defaultExpectation.params) {
			mmRemoveFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveFromCart.defaultExpectation.params)
		}
	}

	return mmRemoveFromCart
}

// Inspect accepts an inspector function that has same arguments as the Service.RemoveFromCart
func (mmRemoveFromCart *mServiceMockRemoveFromCart) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mServiceMockRemoveFromCart {
	if mmRemoveFromCart.mock.inspectFuncRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("Inspect function is already set for ServiceMock.RemoveFromCart")
	}

	mmRemoveFromCart.mock.inspectFuncRemoveFromCart = f

	return mmRemoveFromCart
}

// Return sets up results that will be returned by Service.RemoveFromCart
func (mmRemoveFromCart *mServiceMockRemoveFromCart) Return(err error) *ServiceMock {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("ServiceMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &ServiceMockRemoveFromCartExpectation{mock: mmRemoveFromCart.mock}
	}
	mmRemoveFromCart.defaultExpectation.results = &ServiceMockRemoveFromCartResults{err}
	return mmRemoveFromCart.mock
}

// Set uses given function f to mock the Service.RemoveFromCart method
func (mmRemoveFromCart *mServiceMockRemoveFromCart) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *ServiceMock {
	if mmRemoveFromCart.defaultExpectation != nil {
		mmRemoveFromCart.mock.t.Fatalf("Default expectation is already set for the Service.RemoveFromCart method")
	}

	if len(mmRemoveFromCart.expectations) > 0 {
		mmRemoveFromCart.mock.t.Fatalf("Some expectations are already set for the Service.RemoveFromCart method")
	}

	mmRemoveFromCart.mock.funcRemoveFromCart = f
	return mmRemoveFromCart.mock
}

// When sets expectation for the Service.RemoveFromCart which will trigger the result defined by the following
// Then helper
func (mmRemoveFromCart *mServiceMockRemoveFromCart) When(ctx context.Context, userID int64, skuID int64) *ServiceMockRemoveFromCartExpectation {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("ServiceMock.RemoveFromCart mock is already set by Set")
	}

	expectation := &ServiceMockRemoveFromCartExpectation{
		mock:   mmRemoveFromCart.mock,
		params: &ServiceMockRemoveFromCartParams{ctx, userID, skuID},
	}
	mmRemoveFromCart.expectations = append(mmRemoveFromCart.expectations, expectation)
	return expectation
}

// Then sets up Service.RemoveFromCart return parameters for the expectation previously defined by the When method
func (e *ServiceMockRemoveFromCartExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockRemoveFromCartResults{err}
	return e.mock
}

// RemoveFromCart implements handler.Service
func (mmRemoveFromCart *ServiceMock) RemoveFromCart(ctx context.Context, userID int64, skuID int64) (err error) {
	mm_atomic.AddUint64(&mmRemoveFromCart.beforeRemoveFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveFromCart.afterRemoveFromCartCounter, 1)

	if mmRemoveFromCart.inspectFuncRemoveFromCart != nil {
		mmRemoveFromCart.inspectFuncRemoveFromCart(ctx, userID, skuID)
	}

	mm_params := ServiceMockRemoveFromCartParams{ctx, userID, skuID}

	// Record call args
	mmRemoveFromCart.RemoveFromCartMock.mutex.Lock()
	mmRemoveFromCart.RemoveFromCartMock.callArgs = append(mmRemoveFromCart.RemoveFromCartMock.callArgs, &mm_params)
	mmRemoveFromCart.RemoveFromCartMock.mutex.Unlock()

	for _, e := range mmRemoveFromCart.RemoveFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveFromCart.RemoveFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.params
		mm_got := ServiceMockRemoveFromCartParams{ctx, userID, skuID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveFromCart.t.Errorf("ServiceMock.RemoveFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveFromCart.t.Fatal("No results are set for the ServiceMock.RemoveFromCart")
		}
		return (*mm_results).err
	}
	if mmRemoveFromCart.funcRemoveFromCart != nil {
		return mmRemoveFromCart.funcRemoveFromCart(ctx, userID, skuID)
	}
	mmRemoveFromCart.t.Fatalf("Unexpected call to ServiceMock.RemoveFromCart. %v %v %v", ctx, userID, skuID)
	return
}

// RemoveFromCartAfterCounter returns a count of finished ServiceMock.RemoveFromCart invocations
func (mmRemoveFromCart *ServiceMock) RemoveFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFromCart.afterRemoveFromCartCounter)
}

// RemoveFromCartBeforeCounter returns a count of ServiceMock.RemoveFromCart invocations
func (mmRemoveFromCart *ServiceMock) RemoveFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFromCart.beforeRemoveFromCartCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.RemoveFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveFromCart *mServiceMockRemoveFromCart) Calls() []*ServiceMockRemoveFromCartParams {
	mmRemoveFromCart.mutex.RLock()

	argCopy := make([]*ServiceMockRemoveFromCartParams, len(mmRemoveFromCart.callArgs))
	copy(argCopy, mmRemoveFromCart.callArgs)

	mmRemoveFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveFromCartDone returns true if the count of the RemoveFromCart invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRemoveFromCartDone() bool {
	for _, e := range m.RemoveFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFromCart != nil && mm_atomic.LoadUint64(&m.afterRemoveFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveFromCartInspect logs each unmet expectation
func (m *ServiceMock) MinimockRemoveFromCartInspect() {
	for _, e := range m.RemoveFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.RemoveFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveFromCartCounter) < 1 {
		if m.RemoveFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.RemoveFromCart")
		} else {
			m.t.Errorf("Expected call to ServiceMock.RemoveFromCart with params: %#v", *m.RemoveFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFromCart != nil && mm_atomic.LoadUint64(&m.afterRemoveFromCartCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.RemoveFromCart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddToCartInspect()

			m.MinimockCleanUpCartInspect()

			m.MinimockGetCartInspect()

			m.MinimockRemoveFromCartInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockCleanUpCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockRemoveFromCartDone()
}
