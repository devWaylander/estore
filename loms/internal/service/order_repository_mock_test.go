// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package service

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service.OrderRepository -o order_repository_mock_test.go -n OrderRepositoryMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	orders_repo "route256.ozon.ru/project/loms/internal/repo/db_repo/orders"
)

// OrderRepositoryMock implements OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateItem          func(ctx context.Context, arg orders_repo.CreateItemParams) (err error)
	inspectFuncCreateItem   func(ctx context.Context, arg orders_repo.CreateItemParams)
	afterCreateItemCounter  uint64
	beforeCreateItemCounter uint64
	CreateItemMock          mOrderRepositoryMockCreateItem

	funcCreateOrder          func(ctx context.Context, userID int64) (i1 int64, err error)
	inspectFuncCreateOrder   func(ctx context.Context, userID int64)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mOrderRepositoryMockCreateOrder

	funcGetItemsByOrderID          func(ctx context.Context, orderID int64) (ga1 []orders_repo.GetItemsByOrderIDRow, err error)
	inspectFuncGetItemsByOrderID   func(ctx context.Context, orderID int64)
	afterGetItemsByOrderIDCounter  uint64
	beforeGetItemsByOrderIDCounter uint64
	GetItemsByOrderIDMock          mOrderRepositoryMockGetItemsByOrderID

	funcGetOrder          func(ctx context.Context, id int64) (g1 orders_repo.GetOrderRow, err error)
	inspectFuncGetOrder   func(ctx context.Context, id int64)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mOrderRepositoryMockGetOrder

	funcUpdateOrder          func(ctx context.Context, arg orders_repo.UpdateOrderParams) (err error)
	inspectFuncUpdateOrder   func(ctx context.Context, arg orders_repo.UpdateOrderParams)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mOrderRepositoryMockUpdateOrder
}

// NewOrderRepositoryMock returns a mock for OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateItemMock = mOrderRepositoryMockCreateItem{mock: m}
	m.CreateItemMock.callArgs = []*OrderRepositoryMockCreateItemParams{}

	m.CreateOrderMock = mOrderRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*OrderRepositoryMockCreateOrderParams{}

	m.GetItemsByOrderIDMock = mOrderRepositoryMockGetItemsByOrderID{mock: m}
	m.GetItemsByOrderIDMock.callArgs = []*OrderRepositoryMockGetItemsByOrderIDParams{}

	m.GetOrderMock = mOrderRepositoryMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*OrderRepositoryMockGetOrderParams{}

	m.UpdateOrderMock = mOrderRepositoryMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*OrderRepositoryMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockCreateItem struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateItemExpectation
	expectations       []*OrderRepositoryMockCreateItemExpectation

	callArgs []*OrderRepositoryMockCreateItemParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockCreateItemExpectation specifies expectation struct of the OrderRepository.CreateItem
type OrderRepositoryMockCreateItemExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockCreateItemParams
	results *OrderRepositoryMockCreateItemResults
	Counter uint64
}

// OrderRepositoryMockCreateItemParams contains parameters of the OrderRepository.CreateItem
type OrderRepositoryMockCreateItemParams struct {
	ctx context.Context
	arg orders_repo.CreateItemParams
}

// OrderRepositoryMockCreateItemResults contains results of the OrderRepository.CreateItem
type OrderRepositoryMockCreateItemResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.CreateItem
func (mmCreateItem *mOrderRepositoryMockCreateItem) Expect(ctx context.Context, arg orders_repo.CreateItemParams) *mOrderRepositoryMockCreateItem {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("OrderRepositoryMock.CreateItem mock is already set by Set")
	}

	if mmCreateItem.defaultExpectation == nil {
		mmCreateItem.defaultExpectation = &OrderRepositoryMockCreateItemExpectation{}
	}

	mmCreateItem.defaultExpectation.params = &OrderRepositoryMockCreateItemParams{ctx, arg}
	for _, e := range mmCreateItem.expectations {
		if minimock.Equal(e.params, mmCreateItem.defaultExpectation.params) {
			mmCreateItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateItem.defaultExpectation.params)
		}
	}

	return mmCreateItem
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.CreateItem
func (mmCreateItem *mOrderRepositoryMockCreateItem) Inspect(f func(ctx context.Context, arg orders_repo.CreateItemParams)) *mOrderRepositoryMockCreateItem {
	if mmCreateItem.mock.inspectFuncCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.CreateItem")
	}

	mmCreateItem.mock.inspectFuncCreateItem = f

	return mmCreateItem
}

// Return sets up results that will be returned by OrderRepository.CreateItem
func (mmCreateItem *mOrderRepositoryMockCreateItem) Return(err error) *OrderRepositoryMock {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("OrderRepositoryMock.CreateItem mock is already set by Set")
	}

	if mmCreateItem.defaultExpectation == nil {
		mmCreateItem.defaultExpectation = &OrderRepositoryMockCreateItemExpectation{mock: mmCreateItem.mock}
	}
	mmCreateItem.defaultExpectation.results = &OrderRepositoryMockCreateItemResults{err}
	return mmCreateItem.mock
}

// Set uses given function f to mock the OrderRepository.CreateItem method
func (mmCreateItem *mOrderRepositoryMockCreateItem) Set(f func(ctx context.Context, arg orders_repo.CreateItemParams) (err error)) *OrderRepositoryMock {
	if mmCreateItem.defaultExpectation != nil {
		mmCreateItem.mock.t.Fatalf("Default expectation is already set for the OrderRepository.CreateItem method")
	}

	if len(mmCreateItem.expectations) > 0 {
		mmCreateItem.mock.t.Fatalf("Some expectations are already set for the OrderRepository.CreateItem method")
	}

	mmCreateItem.mock.funcCreateItem = f
	return mmCreateItem.mock
}

// When sets expectation for the OrderRepository.CreateItem which will trigger the result defined by the following
// Then helper
func (mmCreateItem *mOrderRepositoryMockCreateItem) When(ctx context.Context, arg orders_repo.CreateItemParams) *OrderRepositoryMockCreateItemExpectation {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("OrderRepositoryMock.CreateItem mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateItemExpectation{
		mock:   mmCreateItem.mock,
		params: &OrderRepositoryMockCreateItemParams{ctx, arg},
	}
	mmCreateItem.expectations = append(mmCreateItem.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.CreateItem return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateItemExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateItemResults{err}
	return e.mock
}

// CreateItem implements OrderRepository
func (mmCreateItem *OrderRepositoryMock) CreateItem(ctx context.Context, arg orders_repo.CreateItemParams) (err error) {
	mm_atomic.AddUint64(&mmCreateItem.beforeCreateItemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateItem.afterCreateItemCounter, 1)

	if mmCreateItem.inspectFuncCreateItem != nil {
		mmCreateItem.inspectFuncCreateItem(ctx, arg)
	}

	mm_params := OrderRepositoryMockCreateItemParams{ctx, arg}

	// Record call args
	mmCreateItem.CreateItemMock.mutex.Lock()
	mmCreateItem.CreateItemMock.callArgs = append(mmCreateItem.CreateItemMock.callArgs, &mm_params)
	mmCreateItem.CreateItemMock.mutex.Unlock()

	for _, e := range mmCreateItem.CreateItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateItem.CreateItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateItem.CreateItemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateItem.CreateItemMock.defaultExpectation.params
		mm_got := OrderRepositoryMockCreateItemParams{ctx, arg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateItem.t.Errorf("OrderRepositoryMock.CreateItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateItem.CreateItemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateItem.t.Fatal("No results are set for the OrderRepositoryMock.CreateItem")
		}
		return (*mm_results).err
	}
	if mmCreateItem.funcCreateItem != nil {
		return mmCreateItem.funcCreateItem(ctx, arg)
	}
	mmCreateItem.t.Fatalf("Unexpected call to OrderRepositoryMock.CreateItem. %v %v", ctx, arg)
	return
}

// CreateItemAfterCounter returns a count of finished OrderRepositoryMock.CreateItem invocations
func (mmCreateItem *OrderRepositoryMock) CreateItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateItem.afterCreateItemCounter)
}

// CreateItemBeforeCounter returns a count of OrderRepositoryMock.CreateItem invocations
func (mmCreateItem *OrderRepositoryMock) CreateItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateItem.beforeCreateItemCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.CreateItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateItem *mOrderRepositoryMockCreateItem) Calls() []*OrderRepositoryMockCreateItemParams {
	mmCreateItem.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateItemParams, len(mmCreateItem.callArgs))
	copy(argCopy, mmCreateItem.callArgs)

	mmCreateItem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateItemDone returns true if the count of the CreateItem invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateItemDone() bool {
	for _, e := range m.CreateItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateItem != nil && mm_atomic.LoadUint64(&m.afterCreateItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateItemInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateItemInspect() {
	for _, e := range m.CreateItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateItemCounter) < 1 {
		if m.CreateItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.CreateItem")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateItem with params: %#v", *m.CreateItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateItem != nil && mm_atomic.LoadUint64(&m.afterCreateItemCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.CreateItem")
	}
}

type mOrderRepositoryMockCreateOrder struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateOrderExpectation
	expectations       []*OrderRepositoryMockCreateOrderExpectation

	callArgs []*OrderRepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockCreateOrderExpectation specifies expectation struct of the OrderRepository.CreateOrder
type OrderRepositoryMockCreateOrderExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockCreateOrderParams
	results *OrderRepositoryMockCreateOrderResults
	Counter uint64
}

// OrderRepositoryMockCreateOrderParams contains parameters of the OrderRepository.CreateOrder
type OrderRepositoryMockCreateOrderParams struct {
	ctx    context.Context
	userID int64
}

// OrderRepositoryMockCreateOrderResults contains results of the OrderRepository.CreateOrder
type OrderRepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for OrderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Expect(ctx context.Context, userID int64) *mOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &OrderRepositoryMockCreateOrderParams{ctx, userID}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, userID int64)) *mOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by OrderRepository.CreateOrder
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Return(i1 int64, err error) *OrderRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &OrderRepositoryMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the OrderRepository.CreateOrder method
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Set(f func(ctx context.Context, userID int64) (i1 int64, err error)) *OrderRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the OrderRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) When(ctx context.Context, userID int64) *OrderRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &OrderRepositoryMockCreateOrderParams{ctx, userID},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements OrderRepository
func (mmCreateOrder *OrderRepositoryMock) CreateOrder(ctx context.Context, userID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, userID)
	}

	mm_params := OrderRepositoryMockCreateOrderParams{ctx, userID}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := OrderRepositoryMockCreateOrderParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("OrderRepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the OrderRepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, userID)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.CreateOrder. %v %v", ctx, userID)
	return
}

// CreateOrderAfterCounter returns a count of finished OrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *OrderRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of OrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *OrderRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mOrderRepositoryMockCreateOrder) Calls() []*OrderRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.CreateOrder")
	}
}

type mOrderRepositoryMockGetItemsByOrderID struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetItemsByOrderIDExpectation
	expectations       []*OrderRepositoryMockGetItemsByOrderIDExpectation

	callArgs []*OrderRepositoryMockGetItemsByOrderIDParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockGetItemsByOrderIDExpectation specifies expectation struct of the OrderRepository.GetItemsByOrderID
type OrderRepositoryMockGetItemsByOrderIDExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockGetItemsByOrderIDParams
	results *OrderRepositoryMockGetItemsByOrderIDResults
	Counter uint64
}

// OrderRepositoryMockGetItemsByOrderIDParams contains parameters of the OrderRepository.GetItemsByOrderID
type OrderRepositoryMockGetItemsByOrderIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderRepositoryMockGetItemsByOrderIDResults contains results of the OrderRepository.GetItemsByOrderID
type OrderRepositoryMockGetItemsByOrderIDResults struct {
	ga1 []orders_repo.GetItemsByOrderIDRow
	err error
}

// Expect sets up expected params for OrderRepository.GetItemsByOrderID
func (mmGetItemsByOrderID *mOrderRepositoryMockGetItemsByOrderID) Expect(ctx context.Context, orderID int64) *mOrderRepositoryMockGetItemsByOrderID {
	if mmGetItemsByOrderID.mock.funcGetItemsByOrderID != nil {
		mmGetItemsByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetItemsByOrderID mock is already set by Set")
	}

	if mmGetItemsByOrderID.defaultExpectation == nil {
		mmGetItemsByOrderID.defaultExpectation = &OrderRepositoryMockGetItemsByOrderIDExpectation{}
	}

	mmGetItemsByOrderID.defaultExpectation.params = &OrderRepositoryMockGetItemsByOrderIDParams{ctx, orderID}
	for _, e := range mmGetItemsByOrderID.expectations {
		if minimock.Equal(e.params, mmGetItemsByOrderID.defaultExpectation.params) {
			mmGetItemsByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByOrderID.defaultExpectation.params)
		}
	}

	return mmGetItemsByOrderID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetItemsByOrderID
func (mmGetItemsByOrderID *mOrderRepositoryMockGetItemsByOrderID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderRepositoryMockGetItemsByOrderID {
	if mmGetItemsByOrderID.mock.inspectFuncGetItemsByOrderID != nil {
		mmGetItemsByOrderID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetItemsByOrderID")
	}

	mmGetItemsByOrderID.mock.inspectFuncGetItemsByOrderID = f

	return mmGetItemsByOrderID
}

// Return sets up results that will be returned by OrderRepository.GetItemsByOrderID
func (mmGetItemsByOrderID *mOrderRepositoryMockGetItemsByOrderID) Return(ga1 []orders_repo.GetItemsByOrderIDRow, err error) *OrderRepositoryMock {
	if mmGetItemsByOrderID.mock.funcGetItemsByOrderID != nil {
		mmGetItemsByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetItemsByOrderID mock is already set by Set")
	}

	if mmGetItemsByOrderID.defaultExpectation == nil {
		mmGetItemsByOrderID.defaultExpectation = &OrderRepositoryMockGetItemsByOrderIDExpectation{mock: mmGetItemsByOrderID.mock}
	}
	mmGetItemsByOrderID.defaultExpectation.results = &OrderRepositoryMockGetItemsByOrderIDResults{ga1, err}
	return mmGetItemsByOrderID.mock
}

// Set uses given function f to mock the OrderRepository.GetItemsByOrderID method
func (mmGetItemsByOrderID *mOrderRepositoryMockGetItemsByOrderID) Set(f func(ctx context.Context, orderID int64) (ga1 []orders_repo.GetItemsByOrderIDRow, err error)) *OrderRepositoryMock {
	if mmGetItemsByOrderID.defaultExpectation != nil {
		mmGetItemsByOrderID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetItemsByOrderID method")
	}

	if len(mmGetItemsByOrderID.expectations) > 0 {
		mmGetItemsByOrderID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetItemsByOrderID method")
	}

	mmGetItemsByOrderID.mock.funcGetItemsByOrderID = f
	return mmGetItemsByOrderID.mock
}

// When sets expectation for the OrderRepository.GetItemsByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByOrderID *mOrderRepositoryMockGetItemsByOrderID) When(ctx context.Context, orderID int64) *OrderRepositoryMockGetItemsByOrderIDExpectation {
	if mmGetItemsByOrderID.mock.funcGetItemsByOrderID != nil {
		mmGetItemsByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetItemsByOrderID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetItemsByOrderIDExpectation{
		mock:   mmGetItemsByOrderID.mock,
		params: &OrderRepositoryMockGetItemsByOrderIDParams{ctx, orderID},
	}
	mmGetItemsByOrderID.expectations = append(mmGetItemsByOrderID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetItemsByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetItemsByOrderIDExpectation) Then(ga1 []orders_repo.GetItemsByOrderIDRow, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetItemsByOrderIDResults{ga1, err}
	return e.mock
}

// GetItemsByOrderID implements OrderRepository
func (mmGetItemsByOrderID *OrderRepositoryMock) GetItemsByOrderID(ctx context.Context, orderID int64) (ga1 []orders_repo.GetItemsByOrderIDRow, err error) {
	mm_atomic.AddUint64(&mmGetItemsByOrderID.beforeGetItemsByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByOrderID.afterGetItemsByOrderIDCounter, 1)

	if mmGetItemsByOrderID.inspectFuncGetItemsByOrderID != nil {
		mmGetItemsByOrderID.inspectFuncGetItemsByOrderID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetItemsByOrderIDParams{ctx, orderID}

	// Record call args
	mmGetItemsByOrderID.GetItemsByOrderIDMock.mutex.Lock()
	mmGetItemsByOrderID.GetItemsByOrderIDMock.callArgs = append(mmGetItemsByOrderID.GetItemsByOrderIDMock.callArgs, &mm_params)
	mmGetItemsByOrderID.GetItemsByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByOrderID.GetItemsByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ga1, e.results.err
		}
	}

	if mmGetItemsByOrderID.GetItemsByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByOrderID.GetItemsByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByOrderID.GetItemsByOrderIDMock.defaultExpectation.params
		mm_got := OrderRepositoryMockGetItemsByOrderIDParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByOrderID.t.Errorf("OrderRepositoryMock.GetItemsByOrderID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByOrderID.GetItemsByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByOrderID.t.Fatal("No results are set for the OrderRepositoryMock.GetItemsByOrderID")
		}
		return (*mm_results).ga1, (*mm_results).err
	}
	if mmGetItemsByOrderID.funcGetItemsByOrderID != nil {
		return mmGetItemsByOrderID.funcGetItemsByOrderID(ctx, orderID)
	}
	mmGetItemsByOrderID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetItemsByOrderID. %v %v", ctx, orderID)
	return
}

// GetItemsByOrderIDAfterCounter returns a count of finished OrderRepositoryMock.GetItemsByOrderID invocations
func (mmGetItemsByOrderID *OrderRepositoryMock) GetItemsByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByOrderID.afterGetItemsByOrderIDCounter)
}

// GetItemsByOrderIDBeforeCounter returns a count of OrderRepositoryMock.GetItemsByOrderID invocations
func (mmGetItemsByOrderID *OrderRepositoryMock) GetItemsByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByOrderID.beforeGetItemsByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetItemsByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByOrderID *mOrderRepositoryMockGetItemsByOrderID) Calls() []*OrderRepositoryMockGetItemsByOrderIDParams {
	mmGetItemsByOrderID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetItemsByOrderIDParams, len(mmGetItemsByOrderID.callArgs))
	copy(argCopy, mmGetItemsByOrderID.callArgs)

	mmGetItemsByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByOrderIDDone returns true if the count of the GetItemsByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetItemsByOrderIDDone() bool {
	for _, e := range m.GetItemsByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByOrderIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByOrderIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByOrderID != nil && mm_atomic.LoadUint64(&m.afterGetItemsByOrderIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemsByOrderIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetItemsByOrderIDInspect() {
	for _, e := range m.GetItemsByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetItemsByOrderID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByOrderIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemsByOrderIDCounter) < 1 {
		if m.GetItemsByOrderIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.GetItemsByOrderID")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetItemsByOrderID with params: %#v", *m.GetItemsByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByOrderID != nil && mm_atomic.LoadUint64(&m.afterGetItemsByOrderIDCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.GetItemsByOrderID")
	}
}

type mOrderRepositoryMockGetOrder struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetOrderExpectation
	expectations       []*OrderRepositoryMockGetOrderExpectation

	callArgs []*OrderRepositoryMockGetOrderParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockGetOrderExpectation specifies expectation struct of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockGetOrderParams
	results *OrderRepositoryMockGetOrderResults
	Counter uint64
}

// OrderRepositoryMockGetOrderParams contains parameters of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderParams struct {
	ctx context.Context
	id  int64
}

// OrderRepositoryMockGetOrderResults contains results of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderResults struct {
	g1  orders_repo.GetOrderRow
	err error
}

// Expect sets up expected params for OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) Expect(ctx context.Context, id int64) *mOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderRepositoryMockGetOrderExpectation{}
	}

	mmGetOrder.defaultExpectation.params = &OrderRepositoryMockGetOrderParams{ctx, id}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) Inspect(f func(ctx context.Context, id int64)) *mOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) Return(g1 orders_repo.GetOrderRow, err error) *OrderRepositoryMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderRepositoryMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &OrderRepositoryMockGetOrderResults{g1, err}
	return mmGetOrder.mock
}

// Set uses given function f to mock the OrderRepository.GetOrder method
func (mmGetOrder *mOrderRepositoryMockGetOrder) Set(f func(ctx context.Context, id int64) (g1 orders_repo.GetOrderRow, err error)) *OrderRepositoryMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the OrderRepository.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrderRepositoryMockGetOrder) When(ctx context.Context, id int64) *OrderRepositoryMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &OrderRepositoryMockGetOrderParams{ctx, id},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetOrderExpectation) Then(g1 orders_repo.GetOrderRow, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetOrderResults{g1, err}
	return e.mock
}

// GetOrder implements OrderRepository
func (mmGetOrder *OrderRepositoryMock) GetOrder(ctx context.Context, id int64) (g1 orders_repo.GetOrderRow, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, id)
	}

	mm_params := OrderRepositoryMockGetOrderParams{ctx, id}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_got := OrderRepositoryMockGetOrderParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("OrderRepositoryMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the OrderRepositoryMock.GetOrder")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, id)
	}
	mmGetOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.GetOrder. %v %v", ctx, id)
	return
}

// GetOrderAfterCounter returns a count of finished OrderRepositoryMock.GetOrder invocations
func (mmGetOrder *OrderRepositoryMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of OrderRepositoryMock.GetOrder invocations
func (mmGetOrder *OrderRepositoryMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrderRepositoryMockGetOrder) Calls() []*OrderRepositoryMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetOrderDone() bool {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.GetOrder")
	}
}

type mOrderRepositoryMockUpdateOrder struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockUpdateOrderExpectation
	expectations       []*OrderRepositoryMockUpdateOrderExpectation

	callArgs []*OrderRepositoryMockUpdateOrderParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockUpdateOrderExpectation specifies expectation struct of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockUpdateOrderParams
	results *OrderRepositoryMockUpdateOrderResults
	Counter uint64
}

// OrderRepositoryMockUpdateOrderParams contains parameters of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderParams struct {
	ctx context.Context
	arg orders_repo.UpdateOrderParams
}

// OrderRepositoryMockUpdateOrderResults contains results of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Expect(ctx context.Context, arg orders_repo.UpdateOrderParams) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	mmUpdateOrder.defaultExpectation.params = &OrderRepositoryMockUpdateOrderParams{ctx, arg}
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Inspect(f func(ctx context.Context, arg orders_repo.UpdateOrderParams)) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Return(err error) *OrderRepositoryMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &OrderRepositoryMockUpdateOrderResults{err}
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the OrderRepository.UpdateOrder method
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Set(f func(ctx context.Context, arg orders_repo.UpdateOrderParams) (err error)) *OrderRepositoryMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	return mmUpdateOrder.mock
}

// When sets expectation for the OrderRepository.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) When(ctx context.Context, arg orders_repo.UpdateOrderParams) *OrderRepositoryMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockUpdateOrderExpectation{
		mock:   mmUpdateOrder.mock,
		params: &OrderRepositoryMockUpdateOrderParams{ctx, arg},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateOrderExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockUpdateOrderResults{err}
	return e.mock
}

// UpdateOrder implements OrderRepository
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrder(ctx context.Context, arg orders_repo.UpdateOrderParams) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, arg)
	}

	mm_params := OrderRepositoryMockUpdateOrderParams{ctx, arg}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_got := OrderRepositoryMockUpdateOrderParams{ctx, arg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the OrderRepositoryMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, arg)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.UpdateOrder. %v %v", ctx, arg)
	return
}

// UpdateOrderAfterCounter returns a count of finished OrderRepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of OrderRepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Calls() []*OrderRepositoryMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateOrderDone() bool {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.UpdateOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder with params: %#v", *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.UpdateOrder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateItemInspect()

			m.MinimockCreateOrderInspect()

			m.MinimockGetItemsByOrderIDInspect()

			m.MinimockGetOrderInspect()

			m.MinimockUpdateOrderInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateItemDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetItemsByOrderIDDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockUpdateOrderDone()
}
