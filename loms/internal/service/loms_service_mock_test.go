// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package service

//go:generate minimock -i route256.ozon.ru/project/loms/internal/app.LOMSService -o loms_service_mock_test.go -n LOMSServiceMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/loms/internal/model"
)

// LOMSServiceMock implements orders.LOMSService
type LOMSServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOrderCancel          func(ctx context.Context, orderID uint64) (err error)
	inspectFuncOrderCancel   func(ctx context.Context, orderID uint64)
	afterOrderCancelCounter  uint64
	beforeOrderCancelCounter uint64
	OrderCancelMock          mLOMSServiceMockOrderCancel

	funcOrderCreate          func(ctx context.Context, data model.Order) (u1 uint64, err error)
	inspectFuncOrderCreate   func(ctx context.Context, data model.Order)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mLOMSServiceMockOrderCreate

	funcOrderGetInfo          func(ctx context.Context, orderID uint64) (i1 model.Info, err error)
	inspectFuncOrderGetInfo   func(ctx context.Context, orderID uint64)
	afterOrderGetInfoCounter  uint64
	beforeOrderGetInfoCounter uint64
	OrderGetInfoMock          mLOMSServiceMockOrderGetInfo

	funcOrderGetStockInfo          func(ctx context.Context, SKU uint32) (u1 uint64, err error)
	inspectFuncOrderGetStockInfo   func(ctx context.Context, SKU uint32)
	afterOrderGetStockInfoCounter  uint64
	beforeOrderGetStockInfoCounter uint64
	OrderGetStockInfoMock          mLOMSServiceMockOrderGetStockInfo

	funcOrderPay          func(ctx context.Context, orderID uint64) (err error)
	inspectFuncOrderPay   func(ctx context.Context, orderID uint64)
	afterOrderPayCounter  uint64
	beforeOrderPayCounter uint64
	OrderPayMock          mLOMSServiceMockOrderPay
}

// NewLOMSServiceMock returns a mock for orders.LOMSService
func NewLOMSServiceMock(t minimock.Tester) *LOMSServiceMock {
	m := &LOMSServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OrderCancelMock = mLOMSServiceMockOrderCancel{mock: m}
	m.OrderCancelMock.callArgs = []*LOMSServiceMockOrderCancelParams{}

	m.OrderCreateMock = mLOMSServiceMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*LOMSServiceMockOrderCreateParams{}

	m.OrderGetInfoMock = mLOMSServiceMockOrderGetInfo{mock: m}
	m.OrderGetInfoMock.callArgs = []*LOMSServiceMockOrderGetInfoParams{}

	m.OrderGetStockInfoMock = mLOMSServiceMockOrderGetStockInfo{mock: m}
	m.OrderGetStockInfoMock.callArgs = []*LOMSServiceMockOrderGetStockInfoParams{}

	m.OrderPayMock = mLOMSServiceMockOrderPay{mock: m}
	m.OrderPayMock.callArgs = []*LOMSServiceMockOrderPayParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLOMSServiceMockOrderCancel struct {
	mock               *LOMSServiceMock
	defaultExpectation *LOMSServiceMockOrderCancelExpectation
	expectations       []*LOMSServiceMockOrderCancelExpectation

	callArgs []*LOMSServiceMockOrderCancelParams
	mutex    sync.RWMutex
}

// LOMSServiceMockOrderCancelExpectation specifies expectation struct of the LOMSService.OrderCancel
type LOMSServiceMockOrderCancelExpectation struct {
	mock    *LOMSServiceMock
	params  *LOMSServiceMockOrderCancelParams
	results *LOMSServiceMockOrderCancelResults
	Counter uint64
}

// LOMSServiceMockOrderCancelParams contains parameters of the LOMSService.OrderCancel
type LOMSServiceMockOrderCancelParams struct {
	ctx     context.Context
	orderID uint64
}

// LOMSServiceMockOrderCancelResults contains results of the LOMSService.OrderCancel
type LOMSServiceMockOrderCancelResults struct {
	err error
}

// Expect sets up expected params for LOMSService.OrderCancel
func (mmOrderCancel *mLOMSServiceMockOrderCancel) Expect(ctx context.Context, orderID uint64) *mLOMSServiceMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LOMSServiceMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LOMSServiceMockOrderCancelExpectation{}
	}

	mmOrderCancel.defaultExpectation.params = &LOMSServiceMockOrderCancelParams{ctx, orderID}
	for _, e := range mmOrderCancel.expectations {
		if minimock.Equal(e.params, mmOrderCancel.defaultExpectation.params) {
			mmOrderCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCancel.defaultExpectation.params)
		}
	}

	return mmOrderCancel
}

// Inspect accepts an inspector function that has same arguments as the LOMSService.OrderCancel
func (mmOrderCancel *mLOMSServiceMockOrderCancel) Inspect(f func(ctx context.Context, orderID uint64)) *mLOMSServiceMockOrderCancel {
	if mmOrderCancel.mock.inspectFuncOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("Inspect function is already set for LOMSServiceMock.OrderCancel")
	}

	mmOrderCancel.mock.inspectFuncOrderCancel = f

	return mmOrderCancel
}

// Return sets up results that will be returned by LOMSService.OrderCancel
func (mmOrderCancel *mLOMSServiceMockOrderCancel) Return(err error) *LOMSServiceMock {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LOMSServiceMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LOMSServiceMockOrderCancelExpectation{mock: mmOrderCancel.mock}
	}
	mmOrderCancel.defaultExpectation.results = &LOMSServiceMockOrderCancelResults{err}
	return mmOrderCancel.mock
}

// Set uses given function f to mock the LOMSService.OrderCancel method
func (mmOrderCancel *mLOMSServiceMockOrderCancel) Set(f func(ctx context.Context, orderID uint64) (err error)) *LOMSServiceMock {
	if mmOrderCancel.defaultExpectation != nil {
		mmOrderCancel.mock.t.Fatalf("Default expectation is already set for the LOMSService.OrderCancel method")
	}

	if len(mmOrderCancel.expectations) > 0 {
		mmOrderCancel.mock.t.Fatalf("Some expectations are already set for the LOMSService.OrderCancel method")
	}

	mmOrderCancel.mock.funcOrderCancel = f
	return mmOrderCancel.mock
}

// When sets expectation for the LOMSService.OrderCancel which will trigger the result defined by the following
// Then helper
func (mmOrderCancel *mLOMSServiceMockOrderCancel) When(ctx context.Context, orderID uint64) *LOMSServiceMockOrderCancelExpectation {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LOMSServiceMock.OrderCancel mock is already set by Set")
	}

	expectation := &LOMSServiceMockOrderCancelExpectation{
		mock:   mmOrderCancel.mock,
		params: &LOMSServiceMockOrderCancelParams{ctx, orderID},
	}
	mmOrderCancel.expectations = append(mmOrderCancel.expectations, expectation)
	return expectation
}

// Then sets up LOMSService.OrderCancel return parameters for the expectation previously defined by the When method
func (e *LOMSServiceMockOrderCancelExpectation) Then(err error) *LOMSServiceMock {
	e.results = &LOMSServiceMockOrderCancelResults{err}
	return e.mock
}

// OrderCancel implements orders.LOMSService
func (mmOrderCancel *LOMSServiceMock) OrderCancel(ctx context.Context, orderID uint64) (err error) {
	mm_atomic.AddUint64(&mmOrderCancel.beforeOrderCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCancel.afterOrderCancelCounter, 1)

	if mmOrderCancel.inspectFuncOrderCancel != nil {
		mmOrderCancel.inspectFuncOrderCancel(ctx, orderID)
	}

	mm_params := LOMSServiceMockOrderCancelParams{ctx, orderID}

	// Record call args
	mmOrderCancel.OrderCancelMock.mutex.Lock()
	mmOrderCancel.OrderCancelMock.callArgs = append(mmOrderCancel.OrderCancelMock.callArgs, &mm_params)
	mmOrderCancel.OrderCancelMock.mutex.Unlock()

	for _, e := range mmOrderCancel.OrderCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderCancel.OrderCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCancel.OrderCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCancel.OrderCancelMock.defaultExpectation.params
		mm_got := LOMSServiceMockOrderCancelParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCancel.t.Errorf("LOMSServiceMock.OrderCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCancel.OrderCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCancel.t.Fatal("No results are set for the LOMSServiceMock.OrderCancel")
		}
		return (*mm_results).err
	}
	if mmOrderCancel.funcOrderCancel != nil {
		return mmOrderCancel.funcOrderCancel(ctx, orderID)
	}
	mmOrderCancel.t.Fatalf("Unexpected call to LOMSServiceMock.OrderCancel. %v %v", ctx, orderID)
	return
}

// OrderCancelAfterCounter returns a count of finished LOMSServiceMock.OrderCancel invocations
func (mmOrderCancel *LOMSServiceMock) OrderCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.afterOrderCancelCounter)
}

// OrderCancelBeforeCounter returns a count of LOMSServiceMock.OrderCancel invocations
func (mmOrderCancel *LOMSServiceMock) OrderCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.beforeOrderCancelCounter)
}

// Calls returns a list of arguments used in each call to LOMSServiceMock.OrderCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCancel *mLOMSServiceMockOrderCancel) Calls() []*LOMSServiceMockOrderCancelParams {
	mmOrderCancel.mutex.RLock()

	argCopy := make([]*LOMSServiceMockOrderCancelParams, len(mmOrderCancel.callArgs))
	copy(argCopy, mmOrderCancel.callArgs)

	mmOrderCancel.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCancelDone returns true if the count of the OrderCancel invocations corresponds
// the number of defined expectations
func (m *LOMSServiceMock) MinimockOrderCancelDone() bool {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderCancelInspect logs each unmet expectation
func (m *LOMSServiceMock) MinimockOrderCancelInspect() {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderCancel with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		if m.OrderCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSServiceMock.OrderCancel")
		} else {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderCancel with params: %#v", *m.OrderCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && mm_atomic.LoadUint64(&m.afterOrderCancelCounter) < 1 {
		m.t.Error("Expected call to LOMSServiceMock.OrderCancel")
	}
}

type mLOMSServiceMockOrderCreate struct {
	mock               *LOMSServiceMock
	defaultExpectation *LOMSServiceMockOrderCreateExpectation
	expectations       []*LOMSServiceMockOrderCreateExpectation

	callArgs []*LOMSServiceMockOrderCreateParams
	mutex    sync.RWMutex
}

// LOMSServiceMockOrderCreateExpectation specifies expectation struct of the LOMSService.OrderCreate
type LOMSServiceMockOrderCreateExpectation struct {
	mock    *LOMSServiceMock
	params  *LOMSServiceMockOrderCreateParams
	results *LOMSServiceMockOrderCreateResults
	Counter uint64
}

// LOMSServiceMockOrderCreateParams contains parameters of the LOMSService.OrderCreate
type LOMSServiceMockOrderCreateParams struct {
	ctx  context.Context
	data model.Order
}

// LOMSServiceMockOrderCreateResults contains results of the LOMSService.OrderCreate
type LOMSServiceMockOrderCreateResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for LOMSService.OrderCreate
func (mmOrderCreate *mLOMSServiceMockOrderCreate) Expect(ctx context.Context, data model.Order) *mLOMSServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LOMSServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LOMSServiceMockOrderCreateExpectation{}
	}

	mmOrderCreate.defaultExpectation.params = &LOMSServiceMockOrderCreateParams{ctx, data}
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the LOMSService.OrderCreate
func (mmOrderCreate *mLOMSServiceMockOrderCreate) Inspect(f func(ctx context.Context, data model.Order)) *mLOMSServiceMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for LOMSServiceMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by LOMSService.OrderCreate
func (mmOrderCreate *mLOMSServiceMockOrderCreate) Return(u1 uint64, err error) *LOMSServiceMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LOMSServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LOMSServiceMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &LOMSServiceMockOrderCreateResults{u1, err}
	return mmOrderCreate.mock
}

// Set uses given function f to mock the LOMSService.OrderCreate method
func (mmOrderCreate *mLOMSServiceMockOrderCreate) Set(f func(ctx context.Context, data model.Order) (u1 uint64, err error)) *LOMSServiceMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the LOMSService.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the LOMSService.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	return mmOrderCreate.mock
}

// When sets expectation for the LOMSService.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mLOMSServiceMockOrderCreate) When(ctx context.Context, data model.Order) *LOMSServiceMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LOMSServiceMock.OrderCreate mock is already set by Set")
	}

	expectation := &LOMSServiceMockOrderCreateExpectation{
		mock:   mmOrderCreate.mock,
		params: &LOMSServiceMockOrderCreateParams{ctx, data},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up LOMSService.OrderCreate return parameters for the expectation previously defined by the When method
func (e *LOMSServiceMockOrderCreateExpectation) Then(u1 uint64, err error) *LOMSServiceMock {
	e.results = &LOMSServiceMockOrderCreateResults{u1, err}
	return e.mock
}

// OrderCreate implements orders.LOMSService
func (mmOrderCreate *LOMSServiceMock) OrderCreate(ctx context.Context, data model.Order) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, data)
	}

	mm_params := LOMSServiceMockOrderCreateParams{ctx, data}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_got := LOMSServiceMockOrderCreateParams{ctx, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("LOMSServiceMock.OrderCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the LOMSServiceMock.OrderCreate")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, data)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to LOMSServiceMock.OrderCreate. %v %v", ctx, data)
	return
}

// OrderCreateAfterCounter returns a count of finished LOMSServiceMock.OrderCreate invocations
func (mmOrderCreate *LOMSServiceMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of LOMSServiceMock.OrderCreate invocations
func (mmOrderCreate *LOMSServiceMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to LOMSServiceMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mLOMSServiceMockOrderCreate) Calls() []*LOMSServiceMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*LOMSServiceMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *LOMSServiceMock) MinimockOrderCreateDone() bool {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *LOMSServiceMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderCreate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSServiceMock.OrderCreate")
		} else {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderCreate with params: %#v", *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && mm_atomic.LoadUint64(&m.afterOrderCreateCounter) < 1 {
		m.t.Error("Expected call to LOMSServiceMock.OrderCreate")
	}
}

type mLOMSServiceMockOrderGetInfo struct {
	mock               *LOMSServiceMock
	defaultExpectation *LOMSServiceMockOrderGetInfoExpectation
	expectations       []*LOMSServiceMockOrderGetInfoExpectation

	callArgs []*LOMSServiceMockOrderGetInfoParams
	mutex    sync.RWMutex
}

// LOMSServiceMockOrderGetInfoExpectation specifies expectation struct of the LOMSService.OrderGetInfo
type LOMSServiceMockOrderGetInfoExpectation struct {
	mock    *LOMSServiceMock
	params  *LOMSServiceMockOrderGetInfoParams
	results *LOMSServiceMockOrderGetInfoResults
	Counter uint64
}

// LOMSServiceMockOrderGetInfoParams contains parameters of the LOMSService.OrderGetInfo
type LOMSServiceMockOrderGetInfoParams struct {
	ctx     context.Context
	orderID uint64
}

// LOMSServiceMockOrderGetInfoResults contains results of the LOMSService.OrderGetInfo
type LOMSServiceMockOrderGetInfoResults struct {
	i1  model.Info
	err error
}

// Expect sets up expected params for LOMSService.OrderGetInfo
func (mmOrderGetInfo *mLOMSServiceMockOrderGetInfo) Expect(ctx context.Context, orderID uint64) *mLOMSServiceMockOrderGetInfo {
	if mmOrderGetInfo.mock.funcOrderGetInfo != nil {
		mmOrderGetInfo.mock.t.Fatalf("LOMSServiceMock.OrderGetInfo mock is already set by Set")
	}

	if mmOrderGetInfo.defaultExpectation == nil {
		mmOrderGetInfo.defaultExpectation = &LOMSServiceMockOrderGetInfoExpectation{}
	}

	mmOrderGetInfo.defaultExpectation.params = &LOMSServiceMockOrderGetInfoParams{ctx, orderID}
	for _, e := range mmOrderGetInfo.expectations {
		if minimock.Equal(e.params, mmOrderGetInfo.defaultExpectation.params) {
			mmOrderGetInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderGetInfo.defaultExpectation.params)
		}
	}

	return mmOrderGetInfo
}

// Inspect accepts an inspector function that has same arguments as the LOMSService.OrderGetInfo
func (mmOrderGetInfo *mLOMSServiceMockOrderGetInfo) Inspect(f func(ctx context.Context, orderID uint64)) *mLOMSServiceMockOrderGetInfo {
	if mmOrderGetInfo.mock.inspectFuncOrderGetInfo != nil {
		mmOrderGetInfo.mock.t.Fatalf("Inspect function is already set for LOMSServiceMock.OrderGetInfo")
	}

	mmOrderGetInfo.mock.inspectFuncOrderGetInfo = f

	return mmOrderGetInfo
}

// Return sets up results that will be returned by LOMSService.OrderGetInfo
func (mmOrderGetInfo *mLOMSServiceMockOrderGetInfo) Return(i1 model.Info, err error) *LOMSServiceMock {
	if mmOrderGetInfo.mock.funcOrderGetInfo != nil {
		mmOrderGetInfo.mock.t.Fatalf("LOMSServiceMock.OrderGetInfo mock is already set by Set")
	}

	if mmOrderGetInfo.defaultExpectation == nil {
		mmOrderGetInfo.defaultExpectation = &LOMSServiceMockOrderGetInfoExpectation{mock: mmOrderGetInfo.mock}
	}
	mmOrderGetInfo.defaultExpectation.results = &LOMSServiceMockOrderGetInfoResults{i1, err}
	return mmOrderGetInfo.mock
}

// Set uses given function f to mock the LOMSService.OrderGetInfo method
func (mmOrderGetInfo *mLOMSServiceMockOrderGetInfo) Set(f func(ctx context.Context, orderID uint64) (i1 model.Info, err error)) *LOMSServiceMock {
	if mmOrderGetInfo.defaultExpectation != nil {
		mmOrderGetInfo.mock.t.Fatalf("Default expectation is already set for the LOMSService.OrderGetInfo method")
	}

	if len(mmOrderGetInfo.expectations) > 0 {
		mmOrderGetInfo.mock.t.Fatalf("Some expectations are already set for the LOMSService.OrderGetInfo method")
	}

	mmOrderGetInfo.mock.funcOrderGetInfo = f
	return mmOrderGetInfo.mock
}

// When sets expectation for the LOMSService.OrderGetInfo which will trigger the result defined by the following
// Then helper
func (mmOrderGetInfo *mLOMSServiceMockOrderGetInfo) When(ctx context.Context, orderID uint64) *LOMSServiceMockOrderGetInfoExpectation {
	if mmOrderGetInfo.mock.funcOrderGetInfo != nil {
		mmOrderGetInfo.mock.t.Fatalf("LOMSServiceMock.OrderGetInfo mock is already set by Set")
	}

	expectation := &LOMSServiceMockOrderGetInfoExpectation{
		mock:   mmOrderGetInfo.mock,
		params: &LOMSServiceMockOrderGetInfoParams{ctx, orderID},
	}
	mmOrderGetInfo.expectations = append(mmOrderGetInfo.expectations, expectation)
	return expectation
}

// Then sets up LOMSService.OrderGetInfo return parameters for the expectation previously defined by the When method
func (e *LOMSServiceMockOrderGetInfoExpectation) Then(i1 model.Info, err error) *LOMSServiceMock {
	e.results = &LOMSServiceMockOrderGetInfoResults{i1, err}
	return e.mock
}

// OrderGetInfo implements orders.LOMSService
func (mmOrderGetInfo *LOMSServiceMock) OrderGetInfo(ctx context.Context, orderID uint64) (i1 model.Info, err error) {
	mm_atomic.AddUint64(&mmOrderGetInfo.beforeOrderGetInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderGetInfo.afterOrderGetInfoCounter, 1)

	if mmOrderGetInfo.inspectFuncOrderGetInfo != nil {
		mmOrderGetInfo.inspectFuncOrderGetInfo(ctx, orderID)
	}

	mm_params := LOMSServiceMockOrderGetInfoParams{ctx, orderID}

	// Record call args
	mmOrderGetInfo.OrderGetInfoMock.mutex.Lock()
	mmOrderGetInfo.OrderGetInfoMock.callArgs = append(mmOrderGetInfo.OrderGetInfoMock.callArgs, &mm_params)
	mmOrderGetInfo.OrderGetInfoMock.mutex.Unlock()

	for _, e := range mmOrderGetInfo.OrderGetInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmOrderGetInfo.OrderGetInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderGetInfo.OrderGetInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderGetInfo.OrderGetInfoMock.defaultExpectation.params
		mm_got := LOMSServiceMockOrderGetInfoParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderGetInfo.t.Errorf("LOMSServiceMock.OrderGetInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderGetInfo.OrderGetInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderGetInfo.t.Fatal("No results are set for the LOMSServiceMock.OrderGetInfo")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOrderGetInfo.funcOrderGetInfo != nil {
		return mmOrderGetInfo.funcOrderGetInfo(ctx, orderID)
	}
	mmOrderGetInfo.t.Fatalf("Unexpected call to LOMSServiceMock.OrderGetInfo. %v %v", ctx, orderID)
	return
}

// OrderGetInfoAfterCounter returns a count of finished LOMSServiceMock.OrderGetInfo invocations
func (mmOrderGetInfo *LOMSServiceMock) OrderGetInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderGetInfo.afterOrderGetInfoCounter)
}

// OrderGetInfoBeforeCounter returns a count of LOMSServiceMock.OrderGetInfo invocations
func (mmOrderGetInfo *LOMSServiceMock) OrderGetInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderGetInfo.beforeOrderGetInfoCounter)
}

// Calls returns a list of arguments used in each call to LOMSServiceMock.OrderGetInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderGetInfo *mLOMSServiceMockOrderGetInfo) Calls() []*LOMSServiceMockOrderGetInfoParams {
	mmOrderGetInfo.mutex.RLock()

	argCopy := make([]*LOMSServiceMockOrderGetInfoParams, len(mmOrderGetInfo.callArgs))
	copy(argCopy, mmOrderGetInfo.callArgs)

	mmOrderGetInfo.mutex.RUnlock()

	return argCopy
}

// MinimockOrderGetInfoDone returns true if the count of the OrderGetInfo invocations corresponds
// the number of defined expectations
func (m *LOMSServiceMock) MinimockOrderGetInfoDone() bool {
	for _, e := range m.OrderGetInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderGetInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderGetInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderGetInfo != nil && mm_atomic.LoadUint64(&m.afterOrderGetInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderGetInfoInspect logs each unmet expectation
func (m *LOMSServiceMock) MinimockOrderGetInfoInspect() {
	for _, e := range m.OrderGetInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderGetInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderGetInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderGetInfoCounter) < 1 {
		if m.OrderGetInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSServiceMock.OrderGetInfo")
		} else {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderGetInfo with params: %#v", *m.OrderGetInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderGetInfo != nil && mm_atomic.LoadUint64(&m.afterOrderGetInfoCounter) < 1 {
		m.t.Error("Expected call to LOMSServiceMock.OrderGetInfo")
	}
}

type mLOMSServiceMockOrderGetStockInfo struct {
	mock               *LOMSServiceMock
	defaultExpectation *LOMSServiceMockOrderGetStockInfoExpectation
	expectations       []*LOMSServiceMockOrderGetStockInfoExpectation

	callArgs []*LOMSServiceMockOrderGetStockInfoParams
	mutex    sync.RWMutex
}

// LOMSServiceMockOrderGetStockInfoExpectation specifies expectation struct of the LOMSService.OrderGetStockInfo
type LOMSServiceMockOrderGetStockInfoExpectation struct {
	mock    *LOMSServiceMock
	params  *LOMSServiceMockOrderGetStockInfoParams
	results *LOMSServiceMockOrderGetStockInfoResults
	Counter uint64
}

// LOMSServiceMockOrderGetStockInfoParams contains parameters of the LOMSService.OrderGetStockInfo
type LOMSServiceMockOrderGetStockInfoParams struct {
	ctx context.Context
	SKU uint32
}

// LOMSServiceMockOrderGetStockInfoResults contains results of the LOMSService.OrderGetStockInfo
type LOMSServiceMockOrderGetStockInfoResults struct {
	u1  uint64
	err error
}

// Expect sets up expected params for LOMSService.OrderGetStockInfo
func (mmOrderGetStockInfo *mLOMSServiceMockOrderGetStockInfo) Expect(ctx context.Context, SKU uint32) *mLOMSServiceMockOrderGetStockInfo {
	if mmOrderGetStockInfo.mock.funcOrderGetStockInfo != nil {
		mmOrderGetStockInfo.mock.t.Fatalf("LOMSServiceMock.OrderGetStockInfo mock is already set by Set")
	}

	if mmOrderGetStockInfo.defaultExpectation == nil {
		mmOrderGetStockInfo.defaultExpectation = &LOMSServiceMockOrderGetStockInfoExpectation{}
	}

	mmOrderGetStockInfo.defaultExpectation.params = &LOMSServiceMockOrderGetStockInfoParams{ctx, SKU}
	for _, e := range mmOrderGetStockInfo.expectations {
		if minimock.Equal(e.params, mmOrderGetStockInfo.defaultExpectation.params) {
			mmOrderGetStockInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderGetStockInfo.defaultExpectation.params)
		}
	}

	return mmOrderGetStockInfo
}

// Inspect accepts an inspector function that has same arguments as the LOMSService.OrderGetStockInfo
func (mmOrderGetStockInfo *mLOMSServiceMockOrderGetStockInfo) Inspect(f func(ctx context.Context, SKU uint32)) *mLOMSServiceMockOrderGetStockInfo {
	if mmOrderGetStockInfo.mock.inspectFuncOrderGetStockInfo != nil {
		mmOrderGetStockInfo.mock.t.Fatalf("Inspect function is already set for LOMSServiceMock.OrderGetStockInfo")
	}

	mmOrderGetStockInfo.mock.inspectFuncOrderGetStockInfo = f

	return mmOrderGetStockInfo
}

// Return sets up results that will be returned by LOMSService.OrderGetStockInfo
func (mmOrderGetStockInfo *mLOMSServiceMockOrderGetStockInfo) Return(u1 uint64, err error) *LOMSServiceMock {
	if mmOrderGetStockInfo.mock.funcOrderGetStockInfo != nil {
		mmOrderGetStockInfo.mock.t.Fatalf("LOMSServiceMock.OrderGetStockInfo mock is already set by Set")
	}

	if mmOrderGetStockInfo.defaultExpectation == nil {
		mmOrderGetStockInfo.defaultExpectation = &LOMSServiceMockOrderGetStockInfoExpectation{mock: mmOrderGetStockInfo.mock}
	}
	mmOrderGetStockInfo.defaultExpectation.results = &LOMSServiceMockOrderGetStockInfoResults{u1, err}
	return mmOrderGetStockInfo.mock
}

// Set uses given function f to mock the LOMSService.OrderGetStockInfo method
func (mmOrderGetStockInfo *mLOMSServiceMockOrderGetStockInfo) Set(f func(ctx context.Context, SKU uint32) (u1 uint64, err error)) *LOMSServiceMock {
	if mmOrderGetStockInfo.defaultExpectation != nil {
		mmOrderGetStockInfo.mock.t.Fatalf("Default expectation is already set for the LOMSService.OrderGetStockInfo method")
	}

	if len(mmOrderGetStockInfo.expectations) > 0 {
		mmOrderGetStockInfo.mock.t.Fatalf("Some expectations are already set for the LOMSService.OrderGetStockInfo method")
	}

	mmOrderGetStockInfo.mock.funcOrderGetStockInfo = f
	return mmOrderGetStockInfo.mock
}

// When sets expectation for the LOMSService.OrderGetStockInfo which will trigger the result defined by the following
// Then helper
func (mmOrderGetStockInfo *mLOMSServiceMockOrderGetStockInfo) When(ctx context.Context, SKU uint32) *LOMSServiceMockOrderGetStockInfoExpectation {
	if mmOrderGetStockInfo.mock.funcOrderGetStockInfo != nil {
		mmOrderGetStockInfo.mock.t.Fatalf("LOMSServiceMock.OrderGetStockInfo mock is already set by Set")
	}

	expectation := &LOMSServiceMockOrderGetStockInfoExpectation{
		mock:   mmOrderGetStockInfo.mock,
		params: &LOMSServiceMockOrderGetStockInfoParams{ctx, SKU},
	}
	mmOrderGetStockInfo.expectations = append(mmOrderGetStockInfo.expectations, expectation)
	return expectation
}

// Then sets up LOMSService.OrderGetStockInfo return parameters for the expectation previously defined by the When method
func (e *LOMSServiceMockOrderGetStockInfoExpectation) Then(u1 uint64, err error) *LOMSServiceMock {
	e.results = &LOMSServiceMockOrderGetStockInfoResults{u1, err}
	return e.mock
}

// OrderGetStockInfo implements orders.LOMSService
func (mmOrderGetStockInfo *LOMSServiceMock) OrderGetStockInfo(ctx context.Context, SKU uint32) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmOrderGetStockInfo.beforeOrderGetStockInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderGetStockInfo.afterOrderGetStockInfoCounter, 1)

	if mmOrderGetStockInfo.inspectFuncOrderGetStockInfo != nil {
		mmOrderGetStockInfo.inspectFuncOrderGetStockInfo(ctx, SKU)
	}

	mm_params := LOMSServiceMockOrderGetStockInfoParams{ctx, SKU}

	// Record call args
	mmOrderGetStockInfo.OrderGetStockInfoMock.mutex.Lock()
	mmOrderGetStockInfo.OrderGetStockInfoMock.callArgs = append(mmOrderGetStockInfo.OrderGetStockInfoMock.callArgs, &mm_params)
	mmOrderGetStockInfo.OrderGetStockInfoMock.mutex.Unlock()

	for _, e := range mmOrderGetStockInfo.OrderGetStockInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmOrderGetStockInfo.OrderGetStockInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderGetStockInfo.OrderGetStockInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderGetStockInfo.OrderGetStockInfoMock.defaultExpectation.params
		mm_got := LOMSServiceMockOrderGetStockInfoParams{ctx, SKU}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderGetStockInfo.t.Errorf("LOMSServiceMock.OrderGetStockInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderGetStockInfo.OrderGetStockInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderGetStockInfo.t.Fatal("No results are set for the LOMSServiceMock.OrderGetStockInfo")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmOrderGetStockInfo.funcOrderGetStockInfo != nil {
		return mmOrderGetStockInfo.funcOrderGetStockInfo(ctx, SKU)
	}
	mmOrderGetStockInfo.t.Fatalf("Unexpected call to LOMSServiceMock.OrderGetStockInfo. %v %v", ctx, SKU)
	return
}

// OrderGetStockInfoAfterCounter returns a count of finished LOMSServiceMock.OrderGetStockInfo invocations
func (mmOrderGetStockInfo *LOMSServiceMock) OrderGetStockInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderGetStockInfo.afterOrderGetStockInfoCounter)
}

// OrderGetStockInfoBeforeCounter returns a count of LOMSServiceMock.OrderGetStockInfo invocations
func (mmOrderGetStockInfo *LOMSServiceMock) OrderGetStockInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderGetStockInfo.beforeOrderGetStockInfoCounter)
}

// Calls returns a list of arguments used in each call to LOMSServiceMock.OrderGetStockInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderGetStockInfo *mLOMSServiceMockOrderGetStockInfo) Calls() []*LOMSServiceMockOrderGetStockInfoParams {
	mmOrderGetStockInfo.mutex.RLock()

	argCopy := make([]*LOMSServiceMockOrderGetStockInfoParams, len(mmOrderGetStockInfo.callArgs))
	copy(argCopy, mmOrderGetStockInfo.callArgs)

	mmOrderGetStockInfo.mutex.RUnlock()

	return argCopy
}

// MinimockOrderGetStockInfoDone returns true if the count of the OrderGetStockInfo invocations corresponds
// the number of defined expectations
func (m *LOMSServiceMock) MinimockOrderGetStockInfoDone() bool {
	for _, e := range m.OrderGetStockInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderGetStockInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderGetStockInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderGetStockInfo != nil && mm_atomic.LoadUint64(&m.afterOrderGetStockInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderGetStockInfoInspect logs each unmet expectation
func (m *LOMSServiceMock) MinimockOrderGetStockInfoInspect() {
	for _, e := range m.OrderGetStockInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderGetStockInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderGetStockInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderGetStockInfoCounter) < 1 {
		if m.OrderGetStockInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSServiceMock.OrderGetStockInfo")
		} else {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderGetStockInfo with params: %#v", *m.OrderGetStockInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderGetStockInfo != nil && mm_atomic.LoadUint64(&m.afterOrderGetStockInfoCounter) < 1 {
		m.t.Error("Expected call to LOMSServiceMock.OrderGetStockInfo")
	}
}

type mLOMSServiceMockOrderPay struct {
	mock               *LOMSServiceMock
	defaultExpectation *LOMSServiceMockOrderPayExpectation
	expectations       []*LOMSServiceMockOrderPayExpectation

	callArgs []*LOMSServiceMockOrderPayParams
	mutex    sync.RWMutex
}

// LOMSServiceMockOrderPayExpectation specifies expectation struct of the LOMSService.OrderPay
type LOMSServiceMockOrderPayExpectation struct {
	mock    *LOMSServiceMock
	params  *LOMSServiceMockOrderPayParams
	results *LOMSServiceMockOrderPayResults
	Counter uint64
}

// LOMSServiceMockOrderPayParams contains parameters of the LOMSService.OrderPay
type LOMSServiceMockOrderPayParams struct {
	ctx     context.Context
	orderID uint64
}

// LOMSServiceMockOrderPayResults contains results of the LOMSService.OrderPay
type LOMSServiceMockOrderPayResults struct {
	err error
}

// Expect sets up expected params for LOMSService.OrderPay
func (mmOrderPay *mLOMSServiceMockOrderPay) Expect(ctx context.Context, orderID uint64) *mLOMSServiceMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LOMSServiceMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LOMSServiceMockOrderPayExpectation{}
	}

	mmOrderPay.defaultExpectation.params = &LOMSServiceMockOrderPayParams{ctx, orderID}
	for _, e := range mmOrderPay.expectations {
		if minimock.Equal(e.params, mmOrderPay.defaultExpectation.params) {
			mmOrderPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPay.defaultExpectation.params)
		}
	}

	return mmOrderPay
}

// Inspect accepts an inspector function that has same arguments as the LOMSService.OrderPay
func (mmOrderPay *mLOMSServiceMockOrderPay) Inspect(f func(ctx context.Context, orderID uint64)) *mLOMSServiceMockOrderPay {
	if mmOrderPay.mock.inspectFuncOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("Inspect function is already set for LOMSServiceMock.OrderPay")
	}

	mmOrderPay.mock.inspectFuncOrderPay = f

	return mmOrderPay
}

// Return sets up results that will be returned by LOMSService.OrderPay
func (mmOrderPay *mLOMSServiceMockOrderPay) Return(err error) *LOMSServiceMock {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LOMSServiceMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LOMSServiceMockOrderPayExpectation{mock: mmOrderPay.mock}
	}
	mmOrderPay.defaultExpectation.results = &LOMSServiceMockOrderPayResults{err}
	return mmOrderPay.mock
}

// Set uses given function f to mock the LOMSService.OrderPay method
func (mmOrderPay *mLOMSServiceMockOrderPay) Set(f func(ctx context.Context, orderID uint64) (err error)) *LOMSServiceMock {
	if mmOrderPay.defaultExpectation != nil {
		mmOrderPay.mock.t.Fatalf("Default expectation is already set for the LOMSService.OrderPay method")
	}

	if len(mmOrderPay.expectations) > 0 {
		mmOrderPay.mock.t.Fatalf("Some expectations are already set for the LOMSService.OrderPay method")
	}

	mmOrderPay.mock.funcOrderPay = f
	return mmOrderPay.mock
}

// When sets expectation for the LOMSService.OrderPay which will trigger the result defined by the following
// Then helper
func (mmOrderPay *mLOMSServiceMockOrderPay) When(ctx context.Context, orderID uint64) *LOMSServiceMockOrderPayExpectation {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LOMSServiceMock.OrderPay mock is already set by Set")
	}

	expectation := &LOMSServiceMockOrderPayExpectation{
		mock:   mmOrderPay.mock,
		params: &LOMSServiceMockOrderPayParams{ctx, orderID},
	}
	mmOrderPay.expectations = append(mmOrderPay.expectations, expectation)
	return expectation
}

// Then sets up LOMSService.OrderPay return parameters for the expectation previously defined by the When method
func (e *LOMSServiceMockOrderPayExpectation) Then(err error) *LOMSServiceMock {
	e.results = &LOMSServiceMockOrderPayResults{err}
	return e.mock
}

// OrderPay implements orders.LOMSService
func (mmOrderPay *LOMSServiceMock) OrderPay(ctx context.Context, orderID uint64) (err error) {
	mm_atomic.AddUint64(&mmOrderPay.beforeOrderPayCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPay.afterOrderPayCounter, 1)

	if mmOrderPay.inspectFuncOrderPay != nil {
		mmOrderPay.inspectFuncOrderPay(ctx, orderID)
	}

	mm_params := LOMSServiceMockOrderPayParams{ctx, orderID}

	// Record call args
	mmOrderPay.OrderPayMock.mutex.Lock()
	mmOrderPay.OrderPayMock.callArgs = append(mmOrderPay.OrderPayMock.callArgs, &mm_params)
	mmOrderPay.OrderPayMock.mutex.Unlock()

	for _, e := range mmOrderPay.OrderPayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPay.OrderPayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPay.OrderPayMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPay.OrderPayMock.defaultExpectation.params
		mm_got := LOMSServiceMockOrderPayParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPay.t.Errorf("LOMSServiceMock.OrderPay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPay.OrderPayMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPay.t.Fatal("No results are set for the LOMSServiceMock.OrderPay")
		}
		return (*mm_results).err
	}
	if mmOrderPay.funcOrderPay != nil {
		return mmOrderPay.funcOrderPay(ctx, orderID)
	}
	mmOrderPay.t.Fatalf("Unexpected call to LOMSServiceMock.OrderPay. %v %v", ctx, orderID)
	return
}

// OrderPayAfterCounter returns a count of finished LOMSServiceMock.OrderPay invocations
func (mmOrderPay *LOMSServiceMock) OrderPayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.afterOrderPayCounter)
}

// OrderPayBeforeCounter returns a count of LOMSServiceMock.OrderPay invocations
func (mmOrderPay *LOMSServiceMock) OrderPayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.beforeOrderPayCounter)
}

// Calls returns a list of arguments used in each call to LOMSServiceMock.OrderPay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPay *mLOMSServiceMockOrderPay) Calls() []*LOMSServiceMockOrderPayParams {
	mmOrderPay.mutex.RLock()

	argCopy := make([]*LOMSServiceMockOrderPayParams, len(mmOrderPay.callArgs))
	copy(argCopy, mmOrderPay.callArgs)

	mmOrderPay.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayDone returns true if the count of the OrderPay invocations corresponds
// the number of defined expectations
func (m *LOMSServiceMock) MinimockOrderPayDone() bool {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderPayInspect logs each unmet expectation
func (m *LOMSServiceMock) MinimockOrderPayInspect() {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderPay with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		if m.OrderPayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSServiceMock.OrderPay")
		} else {
			m.t.Errorf("Expected call to LOMSServiceMock.OrderPay with params: %#v", *m.OrderPayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && mm_atomic.LoadUint64(&m.afterOrderPayCounter) < 1 {
		m.t.Error("Expected call to LOMSServiceMock.OrderPay")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LOMSServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOrderCancelInspect()

			m.MinimockOrderCreateInspect()

			m.MinimockOrderGetInfoInspect()

			m.MinimockOrderGetStockInfoInspect()

			m.MinimockOrderPayInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LOMSServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LOMSServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOrderCancelDone() &&
		m.MinimockOrderCreateDone() &&
		m.MinimockOrderGetInfoDone() &&
		m.MinimockOrderGetStockInfoDone() &&
		m.MinimockOrderPayDone()
}
